<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libfluidsynth: src/fluid_voice.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>src/fluid_voice.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* FluidSynth - A Software Synthesizer</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (C) 2003  Peter Hanappe and others.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment"> * modify it under the terms of the GNU Library General Public License</span>
<a name="l00007"></a>00007 <span class="comment"> * as published by the Free Software Foundation; either version 2 of</span>
<a name="l00008"></a>00008 <span class="comment"> * the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This library is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * Library General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * You should have received a copy of the GNU Library General Public</span>
<a name="l00016"></a>00016 <span class="comment"> * License along with this library; if not, write to the Free</span>
<a name="l00017"></a>00017 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</span>
<a name="l00018"></a>00018 <span class="comment"> * 02111-1307, USA</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include "fluidsynth_priv.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "fluid_voice.h"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "fluid_mod.h"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "fluid_chan.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "fluid_conv.h"</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include "fluid_synth.h"</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "fluid_sys.h"</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include "fluid_sfont.h"</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">/* used for filter turn off optimization - if filter cutoff is above the</span>
<a name="l00031"></a>00031 <span class="comment">   specified value and filter q is below the other value, turn filter off */</span>
<a name="l00032"></a>00032 <span class="preprocessor">#define FLUID_MAX_AUDIBLE_FILTER_FC 19000.0f</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#define FLUID_MIN_AUDIBLE_FILTER_Q 1.2f</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="comment">/* Smallest amplitude that can be perceived (full scale is +/- 0.5)</span>
<a name="l00036"></a>00036 <span class="comment"> * 16 bits =&gt; 96+4=100 dB dynamic range =&gt; 0.00001</span>
<a name="l00037"></a>00037 <span class="comment"> * 0.00001 * 2 is approximately 0.00003 :)</span>
<a name="l00038"></a>00038 <span class="comment"> */</span>
<a name="l00039"></a>00039 <span class="preprocessor">#define FLUID_NOISE_FLOOR 0.00003</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="comment">/* these should be the absolute minimum that FluidSynth can deal with */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#define FLUID_MIN_LOOP_SIZE 2</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define FLUID_MIN_LOOP_PAD 0</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="comment">/* min vol envelope release (to stop clicks) in SoundFont timecents */</span>
<a name="l00046"></a>00046 <span class="preprocessor">#define FLUID_MIN_VOLENVRELEASE -7200.0f </span><span class="comment">/* ~16ms */</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fluid_voice_effects (fluid_voice_t *voice, <span class="keywordtype">int</span> count,
<a name="l00050"></a>00050                                         fluid_real_t* dsp_left_buf,
<a name="l00051"></a>00051                                         fluid_real_t* dsp_right_buf,
<a name="l00052"></a>00052                                         fluid_real_t* dsp_reverb_buf,
<a name="l00053"></a>00053                                         fluid_real_t* dsp_chorus_buf);
<a name="l00054"></a>00054 <span class="comment">/*</span>
<a name="l00055"></a>00055 <span class="comment"> * new_fluid_voice</span>
<a name="l00056"></a>00056 <span class="comment"> */</span>
<a name="l00057"></a>00057 fluid_voice_t*
<a name="l00058"></a>00058 new_fluid_voice(fluid_real_t output_rate)
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060   fluid_voice_t* voice;
<a name="l00061"></a>00061   voice = FLUID_NEW(fluid_voice_t);
<a name="l00062"></a>00062   <span class="keywordflow">if</span> (voice == NULL) {
<a name="l00063"></a>00063     FLUID_LOG(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9ebc0ff48d192b3b0fc721946ccf095d25" title="Serious error occurred.">FLUID_ERR</a>, <span class="stringliteral">"Out of memory"</span>);
<a name="l00064"></a>00064     <span class="keywordflow">return</span> NULL;
<a name="l00065"></a>00065   }
<a name="l00066"></a>00066   voice-&gt;status = FLUID_VOICE_CLEAN;
<a name="l00067"></a>00067   voice-&gt;chan = NO_CHANNEL;
<a name="l00068"></a>00068   voice-&gt;key = 0;
<a name="l00069"></a>00069   voice-&gt;vel = 0;
<a name="l00070"></a>00070   voice-&gt;channel = NULL;
<a name="l00071"></a>00071   voice-&gt;sample = NULL;
<a name="l00072"></a>00072   voice-&gt;output_rate = output_rate;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="comment">/* The 'sustain' and 'finished' segments of the volume / modulation</span>
<a name="l00075"></a>00075 <span class="comment">   * envelope are constant. They are never affected by any modulator</span>
<a name="l00076"></a>00076 <span class="comment">   * or generator. Therefore it is enough to initialize them once</span>
<a name="l00077"></a>00077 <span class="comment">   * during the lifetime of the synth.</span>
<a name="l00078"></a>00078 <span class="comment">   */</span>
<a name="l00079"></a>00079   voice-&gt;volenv_data[FLUID_VOICE_ENVSUSTAIN].count = 0xffffffff;
<a name="l00080"></a>00080   voice-&gt;volenv_data[FLUID_VOICE_ENVSUSTAIN].coeff = 1.0f;
<a name="l00081"></a>00081   voice-&gt;volenv_data[FLUID_VOICE_ENVSUSTAIN].incr = 0.0f;
<a name="l00082"></a>00082   voice-&gt;volenv_data[FLUID_VOICE_ENVSUSTAIN].min = -1.0f;
<a name="l00083"></a>00083   voice-&gt;volenv_data[FLUID_VOICE_ENVSUSTAIN].max = 2.0f;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085   voice-&gt;volenv_data[FLUID_VOICE_ENVFINISHED].count = 0xffffffff;
<a name="l00086"></a>00086   voice-&gt;volenv_data[FLUID_VOICE_ENVFINISHED].coeff = 0.0f;
<a name="l00087"></a>00087   voice-&gt;volenv_data[FLUID_VOICE_ENVFINISHED].incr = 0.0f;
<a name="l00088"></a>00088   voice-&gt;volenv_data[FLUID_VOICE_ENVFINISHED].min = -1.0f;
<a name="l00089"></a>00089   voice-&gt;volenv_data[FLUID_VOICE_ENVFINISHED].max = 1.0f;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   voice-&gt;modenv_data[FLUID_VOICE_ENVSUSTAIN].count = 0xffffffff;
<a name="l00092"></a>00092   voice-&gt;modenv_data[FLUID_VOICE_ENVSUSTAIN].coeff = 1.0f;
<a name="l00093"></a>00093   voice-&gt;modenv_data[FLUID_VOICE_ENVSUSTAIN].incr = 0.0f;
<a name="l00094"></a>00094   voice-&gt;modenv_data[FLUID_VOICE_ENVSUSTAIN].min = -1.0f;
<a name="l00095"></a>00095   voice-&gt;modenv_data[FLUID_VOICE_ENVSUSTAIN].max = 2.0f;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   voice-&gt;modenv_data[FLUID_VOICE_ENVFINISHED].count = 0xffffffff;
<a name="l00098"></a>00098   voice-&gt;modenv_data[FLUID_VOICE_ENVFINISHED].coeff = 0.0f;
<a name="l00099"></a>00099   voice-&gt;modenv_data[FLUID_VOICE_ENVFINISHED].incr = 0.0f;
<a name="l00100"></a>00100   voice-&gt;modenv_data[FLUID_VOICE_ENVFINISHED].min = -1.0f;
<a name="l00101"></a>00101   voice-&gt;modenv_data[FLUID_VOICE_ENVFINISHED].max = 1.0f;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103   <span class="keywordflow">return</span> voice;
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">/*</span>
<a name="l00107"></a>00107 <span class="comment"> * delete_fluid_voice</span>
<a name="l00108"></a>00108 <span class="comment"> */</span>
<a name="l00109"></a>00109 <span class="keywordtype">int</span>
<a name="l00110"></a>00110 delete_fluid_voice(fluid_voice_t* voice)
<a name="l00111"></a>00111 {
<a name="l00112"></a>00112   <span class="keywordflow">if</span> (voice == NULL) {
<a name="l00113"></a>00113     <span class="keywordflow">return</span> FLUID_OK;
<a name="l00114"></a>00114   }
<a name="l00115"></a>00115   FLUID_FREE(voice);
<a name="l00116"></a>00116   <span class="keywordflow">return</span> FLUID_OK;
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/* fluid_voice_init</span>
<a name="l00120"></a>00120 <span class="comment"> *</span>
<a name="l00121"></a>00121 <span class="comment"> * Initialize the synthesis process</span>
<a name="l00122"></a>00122 <span class="comment"> */</span>
<a name="l00123"></a>00123 <span class="keywordtype">int</span>
<a name="l00124"></a>00124 fluid_voice_init(fluid_voice_t* voice, <a class="code" href="struct__fluid__sample__t.html">fluid_sample_t</a>* sample,
<a name="l00125"></a>00125                  fluid_channel_t* channel, <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> vel, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>,
<a name="l00126"></a>00126                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_time, fluid_real_t gain)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128   <span class="comment">/* Note: The voice parameters will be initialized later, when the</span>
<a name="l00129"></a>00129 <span class="comment">   * generators have been retrieved from the sound font. Here, only</span>
<a name="l00130"></a>00130 <span class="comment">   * the 'working memory' of the voice (position in envelopes, history</span>
<a name="l00131"></a>00131 <span class="comment">   * of IIR filters, position in sample etc) is initialized. */</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   voice-&gt;id = id;
<a name="l00135"></a>00135   voice-&gt;chan = fluid_channel_get_num(channel);
<a name="l00136"></a>00136   voice-&gt;key = (<span class="keywordtype">unsigned</span> char) key;
<a name="l00137"></a>00137   voice-&gt;vel = (<span class="keywordtype">unsigned</span> char) vel;
<a name="l00138"></a>00138   voice-&gt;channel = channel;
<a name="l00139"></a>00139   voice-&gt;mod_count = 0;
<a name="l00140"></a>00140   voice-&gt;sample = sample;
<a name="l00141"></a>00141   voice-&gt;start_time = start_time;
<a name="l00142"></a>00142   voice-&gt;ticks = 0;
<a name="l00143"></a>00143   voice-&gt;debug = 0;
<a name="l00144"></a>00144   voice-&gt;has_looped = 0; <span class="comment">/* Will be set during voice_write when the 2nd loop point is reached */</span>
<a name="l00145"></a>00145   voice-&gt;last_fres = -1; <span class="comment">/* The filter coefficients have to be calculated later in the DSP loop. */</span>
<a name="l00146"></a>00146   voice-&gt;filter_startup = 1; <span class="comment">/* Set the filter immediately, don't fade between old and new settings */</span>
<a name="l00147"></a>00147   voice-&gt;interp_method = fluid_channel_get_interp_method(voice-&gt;channel);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   <span class="comment">/* vol env initialization */</span>
<a name="l00150"></a>00150   voice-&gt;volenv_count = 0;
<a name="l00151"></a>00151   voice-&gt;volenv_section = 0;
<a name="l00152"></a>00152   voice-&gt;volenv_val = 0.0f;
<a name="l00153"></a>00153   voice-&gt;amp = 0.0f; <span class="comment">/* The last value of the volume envelope, used to</span>
<a name="l00154"></a>00154 <span class="comment">                        calculate the volume increment during</span>
<a name="l00155"></a>00155 <span class="comment">                        processing */</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="comment">/* mod env initialization*/</span>
<a name="l00158"></a>00158   voice-&gt;modenv_count = 0;
<a name="l00159"></a>00159   voice-&gt;modenv_section = 0;
<a name="l00160"></a>00160   voice-&gt;modenv_val = 0.0f;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="comment">/* mod lfo */</span>
<a name="l00163"></a>00163   voice-&gt;modlfo_val = 0.0;<span class="comment">/* Fixme: Retrieve from any other existing</span>
<a name="l00164"></a>00164 <span class="comment">                             voice on this channel to keep LFOs in</span>
<a name="l00165"></a>00165 <span class="comment">                             unison? */</span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="comment">/* vib lfo */</span>
<a name="l00168"></a>00168   voice-&gt;viblfo_val = 0.0f; <span class="comment">/* Fixme: See mod lfo */</span>
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="comment">/* Clear sample history in filter */</span>
<a name="l00171"></a>00171   voice-&gt;hist1 = 0;
<a name="l00172"></a>00172   voice-&gt;hist2 = 0;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">/* Set all the generators to their default value, according to SF</span>
<a name="l00175"></a>00175 <span class="comment">   * 2.01 section 8.1.3 (page 48). The value of NRPN messages are</span>
<a name="l00176"></a>00176 <span class="comment">   * copied from the channel to the voice's generators. The sound font</span>
<a name="l00177"></a>00177 <span class="comment">   * loader overwrites them. The generator values are later converted</span>
<a name="l00178"></a>00178 <span class="comment">   * into voice parameters in</span>
<a name="l00179"></a>00179 <span class="comment">   * fluid_voice_calculate_runtime_synthesis_parameters.  */</span>
<a name="l00180"></a>00180   fluid_gen_init(&amp;voice-&gt;gen[0], channel);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   voice-&gt;synth_gain = gain;
<a name="l00183"></a>00183   <span class="comment">/* avoid division by zero later*/</span>
<a name="l00184"></a>00184   <span class="keywordflow">if</span> (voice-&gt;synth_gain &lt; 0.0000001){
<a name="l00185"></a>00185     voice-&gt;synth_gain = 0.0000001;
<a name="l00186"></a>00186   }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   <span class="comment">/* For a looped sample, this value will be overwritten as soon as the</span>
<a name="l00189"></a>00189 <span class="comment">   * loop parameters are initialized (they may depend on modulators).</span>
<a name="l00190"></a>00190 <span class="comment">   * This value can be kept, it is a worst-case estimate.</span>
<a name="l00191"></a>00191 <span class="comment">   */</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   voice-&gt;amplitude_that_reaches_noise_floor_nonloop = FLUID_NOISE_FLOOR / voice-&gt;synth_gain;
<a name="l00194"></a>00194   voice-&gt;amplitude_that_reaches_noise_floor_loop = FLUID_NOISE_FLOOR / voice-&gt;synth_gain;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="comment">/* Increment the reference count of the sample to prevent the</span>
<a name="l00197"></a>00197 <span class="comment">     unloading of the soundfont while this voice is playing. */</span>
<a name="l00198"></a>00198   fluid_sample_incr_ref(voice-&gt;sample);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   <span class="keywordflow">return</span> FLUID_OK;
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="keywordtype">void</span> fluid_voice_gen_set(fluid_voice_t* voice, <span class="keywordtype">int</span> i, <span class="keywordtype">float</span> val)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205   voice-&gt;gen[i].val = val;
<a name="l00206"></a>00206   voice-&gt;gen[i].flags = <a class="code" href="gen_8h.html#96f1389ca9e52d85cdf1160a038b4bb5addb45ff06d85814a429100ba9099c1f" title="Generator value is set.">GEN_SET</a>;
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keywordtype">void</span> fluid_voice_gen_incr(fluid_voice_t* voice, <span class="keywordtype">int</span> i, <span class="keywordtype">float</span> val)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211   voice-&gt;gen[i].val += val;
<a name="l00212"></a>00212   voice-&gt;gen[i].flags = <a class="code" href="gen_8h.html#96f1389ca9e52d85cdf1160a038b4bb5addb45ff06d85814a429100ba9099c1f" title="Generator value is set.">GEN_SET</a>;
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="keywordtype">float</span> fluid_voice_gen_get(fluid_voice_t* voice, <span class="keywordtype">int</span> gen)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217   <span class="keywordflow">return</span> voice-&gt;gen[gen].val;
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 fluid_real_t fluid_voice_gen_value(fluid_voice_t* voice, <span class="keywordtype">int</span> num)
<a name="l00221"></a>00221 {
<a name="l00222"></a>00222         <span class="comment">/* This is an extension to the SoundFont standard. More</span>
<a name="l00223"></a>00223 <span class="comment">         * documentation is available at the fluid_synth_set_gen2()</span>
<a name="l00224"></a>00224 <span class="comment">         * function. */</span>
<a name="l00225"></a>00225         <span class="keywordflow">if</span> (voice-&gt;gen[num].flags == <a class="code" href="gen_8h.html#96f1389ca9e52d85cdf1160a038b4bb5d9b34811c11a1b5078befb70b14c2285" title="DOCME.">GEN_ABS_NRPN</a>) {
<a name="l00226"></a>00226                 <span class="keywordflow">return</span> (fluid_real_t) voice-&gt;gen[num].nrpn;
<a name="l00227"></a>00227         } <span class="keywordflow">else</span> {
<a name="l00228"></a>00228                 <span class="keywordflow">return</span> (fluid_real_t) (voice-&gt;gen[num].val + voice-&gt;gen[num].mod + voice-&gt;gen[num].nrpn);
<a name="l00229"></a>00229         }
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="comment">/*</span>
<a name="l00234"></a>00234 <span class="comment"> * fluid_voice_write</span>
<a name="l00235"></a>00235 <span class="comment"> *</span>
<a name="l00236"></a>00236 <span class="comment"> * This is where it all happens. This function is called by the</span>
<a name="l00237"></a>00237 <span class="comment"> * synthesizer to generate the sound samples. The synthesizer passes</span>
<a name="l00238"></a>00238 <span class="comment"> * four audio buffers: left, right, reverb out, and chorus out.</span>
<a name="l00239"></a>00239 <span class="comment"> *</span>
<a name="l00240"></a>00240 <span class="comment"> * The biggest part of this function sets the correct values for all</span>
<a name="l00241"></a>00241 <span class="comment"> * the dsp parameters (all the control data boil down to only a few</span>
<a name="l00242"></a>00242 <span class="comment"> * dsp parameters). The dsp routine is #included in several places (fluid_dsp_core.c).</span>
<a name="l00243"></a>00243 <span class="comment"> */</span>
<a name="l00244"></a>00244 <span class="keywordtype">int</span>
<a name="l00245"></a>00245 fluid_voice_write(fluid_voice_t* voice,
<a name="l00246"></a>00246                  fluid_real_t* dsp_left_buf, fluid_real_t* dsp_right_buf,
<a name="l00247"></a>00247                  fluid_real_t* dsp_reverb_buf, fluid_real_t* dsp_chorus_buf)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00250"></a>00250   fluid_real_t incr;
<a name="l00251"></a>00251   fluid_real_t fres;
<a name="l00252"></a>00252   fluid_real_t target_amp;      <span class="comment">/* target amplitude */</span>
<a name="l00253"></a>00253   <span class="keywordtype">int</span> count;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keywordtype">int</span> dsp_interp_method = voice-&gt;interp_method;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   fluid_real_t dsp_buf[FLUID_BUFSIZE];
<a name="l00258"></a>00258   fluid_env_data_t* env_data;
<a name="l00259"></a>00259   fluid_real_t x;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <span class="comment">/* make sure we're playing and that we have sample data */</span>
<a name="l00263"></a>00263   <span class="keywordflow">if</span> (!_PLAYING(voice)) <span class="keywordflow">return</span> FLUID_OK;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="comment">/******************* sample **********************/</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267   <span class="keywordflow">if</span> (voice-&gt;sample == NULL)
<a name="l00268"></a>00268   {
<a name="l00269"></a>00269     fluid_voice_off(voice);
<a name="l00270"></a>00270     <span class="keywordflow">return</span> FLUID_OK;
<a name="l00271"></a>00271   }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   fluid_check_fpe (<span class="stringliteral">"voice_write startup"</span>);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="comment">/* Range checking for sample- and loop-related parameters</span>
<a name="l00276"></a>00276 <span class="comment">   * Initial phase is calculated here*/</span>
<a name="l00277"></a>00277   fluid_voice_check_sample_sanity (voice);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="comment">/******************* vol env **********************/</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   env_data = &amp;voice-&gt;volenv_data[voice-&gt;volenv_section];
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="comment">/* skip to the next section of the envelope if necessary */</span>
<a name="l00284"></a>00284   <span class="keywordflow">while</span> (voice-&gt;volenv_count &gt;= env_data-&gt;count)
<a name="l00285"></a>00285   {
<a name="l00286"></a>00286     env_data = &amp;voice-&gt;volenv_data[++voice-&gt;volenv_section];
<a name="l00287"></a>00287     voice-&gt;volenv_count = 0;
<a name="l00288"></a>00288   }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">/* calculate the envelope value and check for valid range */</span>
<a name="l00291"></a>00291   x = env_data-&gt;coeff * voice-&gt;volenv_val + env_data-&gt;incr;
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (x &lt; env_data-&gt;min)
<a name="l00293"></a>00293   {
<a name="l00294"></a>00294     x = env_data-&gt;min;
<a name="l00295"></a>00295     voice-&gt;volenv_section++;
<a name="l00296"></a>00296     voice-&gt;volenv_count = 0;
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt; env_data-&gt;max)
<a name="l00299"></a>00299   {
<a name="l00300"></a>00300     x = env_data-&gt;max;
<a name="l00301"></a>00301     voice-&gt;volenv_section++;
<a name="l00302"></a>00302     voice-&gt;volenv_count = 0;
<a name="l00303"></a>00303   }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   voice-&gt;volenv_val = x;
<a name="l00306"></a>00306   voice-&gt;volenv_count++;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">if</span> (voice-&gt;volenv_section == FLUID_VOICE_ENVFINISHED)
<a name="l00309"></a>00309   {
<a name="l00310"></a>00310     fluid_profile (FLUID_PROF_VOICE_RELEASE, voice-&gt;ref);
<a name="l00311"></a>00311     fluid_voice_off (voice);
<a name="l00312"></a>00312     <span class="keywordflow">return</span> FLUID_OK;
<a name="l00313"></a>00313   }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   fluid_check_fpe (<span class="stringliteral">"voice_write vol env"</span>);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="comment">/******************* mod env **********************/</span>
<a name="l00318"></a>00318 
<a name="l00319"></a>00319   env_data = &amp;voice-&gt;modenv_data[voice-&gt;modenv_section];
<a name="l00320"></a>00320 
<a name="l00321"></a>00321   <span class="comment">/* skip to the next section of the envelope if necessary */</span>
<a name="l00322"></a>00322   <span class="keywordflow">while</span> (voice-&gt;modenv_count &gt;= env_data-&gt;count)
<a name="l00323"></a>00323   {
<a name="l00324"></a>00324     env_data = &amp;voice-&gt;modenv_data[++voice-&gt;modenv_section];
<a name="l00325"></a>00325     voice-&gt;modenv_count = 0;
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="comment">/* calculate the envelope value and check for valid range */</span>
<a name="l00329"></a>00329   x = env_data-&gt;coeff * voice-&gt;modenv_val + env_data-&gt;incr;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <span class="keywordflow">if</span> (x &lt; env_data-&gt;min)
<a name="l00332"></a>00332   {
<a name="l00333"></a>00333     x = env_data-&gt;min;
<a name="l00334"></a>00334     voice-&gt;modenv_section++;
<a name="l00335"></a>00335     voice-&gt;modenv_count = 0;
<a name="l00336"></a>00336   }
<a name="l00337"></a>00337   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt; env_data-&gt;max)
<a name="l00338"></a>00338   {
<a name="l00339"></a>00339     x = env_data-&gt;max;
<a name="l00340"></a>00340     voice-&gt;modenv_section++;
<a name="l00341"></a>00341     voice-&gt;modenv_count = 0;
<a name="l00342"></a>00342   }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   voice-&gt;modenv_val = x;
<a name="l00345"></a>00345   voice-&gt;modenv_count++;
<a name="l00346"></a>00346   fluid_check_fpe (<span class="stringliteral">"voice_write mod env"</span>);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="comment">/******************* mod lfo **********************/</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="keywordflow">if</span> (voice-&gt;ticks &gt;= voice-&gt;modlfo_delay)
<a name="l00351"></a>00351   {
<a name="l00352"></a>00352     voice-&gt;modlfo_val += voice-&gt;modlfo_incr;
<a name="l00353"></a>00353   
<a name="l00354"></a>00354     <span class="keywordflow">if</span> (voice-&gt;modlfo_val &gt; 1.0)
<a name="l00355"></a>00355     {
<a name="l00356"></a>00356       voice-&gt;modlfo_incr = -voice-&gt;modlfo_incr;
<a name="l00357"></a>00357       voice-&gt;modlfo_val = (fluid_real_t) 2.0 - voice-&gt;modlfo_val;
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (voice-&gt;modlfo_val &lt; -1.0)
<a name="l00360"></a>00360     {
<a name="l00361"></a>00361       voice-&gt;modlfo_incr = -voice-&gt;modlfo_incr;
<a name="l00362"></a>00362       voice-&gt;modlfo_val = (fluid_real_t) -2.0 - voice-&gt;modlfo_val;
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364   }
<a name="l00365"></a>00365   
<a name="l00366"></a>00366   fluid_check_fpe (<span class="stringliteral">"voice_write mod LFO"</span>);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="comment">/******************* vib lfo **********************/</span>
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="keywordflow">if</span> (voice-&gt;ticks &gt;= voice-&gt;viblfo_delay)
<a name="l00371"></a>00371   {
<a name="l00372"></a>00372     voice-&gt;viblfo_val += voice-&gt;viblfo_incr;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <span class="keywordflow">if</span> (voice-&gt;viblfo_val &gt; (fluid_real_t) 1.0)
<a name="l00375"></a>00375     {
<a name="l00376"></a>00376       voice-&gt;viblfo_incr = -voice-&gt;viblfo_incr;
<a name="l00377"></a>00377       voice-&gt;viblfo_val = (fluid_real_t) 2.0 - voice-&gt;viblfo_val;
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (voice-&gt;viblfo_val &lt; -1.0)
<a name="l00380"></a>00380     {
<a name="l00381"></a>00381       voice-&gt;viblfo_incr = -voice-&gt;viblfo_incr;
<a name="l00382"></a>00382       voice-&gt;viblfo_val = (fluid_real_t) -2.0 - voice-&gt;viblfo_val;
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384   }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   fluid_check_fpe (<span class="stringliteral">"voice_write Vib LFO"</span>);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">/******************* amplitude **********************/</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   <span class="comment">/* calculate final amplitude</span>
<a name="l00391"></a>00391 <span class="comment">   * - initial gain</span>
<a name="l00392"></a>00392 <span class="comment">   * - amplitude envelope</span>
<a name="l00393"></a>00393 <span class="comment">   */</span>
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="keywordflow">if</span> (voice-&gt;volenv_section == FLUID_VOICE_ENVDELAY)
<a name="l00396"></a>00396     <span class="keywordflow">goto</span> post_process;  <span class="comment">/* The volume amplitude is in hold phase. No sound is produced. */</span>
<a name="l00397"></a>00397 
<a name="l00398"></a>00398   <span class="keywordflow">if</span> (voice-&gt;volenv_section == FLUID_VOICE_ENVATTACK)
<a name="l00399"></a>00399   {
<a name="l00400"></a>00400     <span class="comment">/* the envelope is in the attack section: ramp linearly to max value.</span>
<a name="l00401"></a>00401 <span class="comment">     * A positive modlfo_to_vol should increase volume (negative attenuation).</span>
<a name="l00402"></a>00402 <span class="comment">     */</span>
<a name="l00403"></a>00403     target_amp = fluid_atten2amp (voice-&gt;attenuation)
<a name="l00404"></a>00404       * fluid_cb2amp (voice-&gt;modlfo_val * -voice-&gt;modlfo_to_vol)
<a name="l00405"></a>00405       * voice-&gt;volenv_val;
<a name="l00406"></a>00406   }
<a name="l00407"></a>00407   <span class="keywordflow">else</span>
<a name="l00408"></a>00408   {
<a name="l00409"></a>00409     fluid_real_t amplitude_that_reaches_noise_floor;
<a name="l00410"></a>00410     fluid_real_t amp_max;
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     target_amp = fluid_atten2amp (voice-&gt;attenuation)
<a name="l00413"></a>00413       * fluid_cb2amp (960.0f * (1.0f - voice-&gt;volenv_val)
<a name="l00414"></a>00414                       + voice-&gt;modlfo_val * -voice-&gt;modlfo_to_vol);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <span class="comment">/* We turn off a voice, if the volume has dropped low enough. */</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     <span class="comment">/* A voice can be turned off, when an estimate for the volume</span>
<a name="l00419"></a>00419 <span class="comment">     * (upper bound) falls below that volume, that will drop the</span>
<a name="l00420"></a>00420 <span class="comment">     * sample below the noise floor.</span>
<a name="l00421"></a>00421 <span class="comment">     */</span>
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">/* If the loop amplitude is known, we can use it if the voice loop is within</span>
<a name="l00424"></a>00424 <span class="comment">     * the sample loop</span>
<a name="l00425"></a>00425 <span class="comment">     */</span>
<a name="l00426"></a>00426 
<a name="l00427"></a>00427     <span class="comment">/* Is the playing pointer already in the loop? */</span>
<a name="l00428"></a>00428     <span class="keywordflow">if</span> (voice-&gt;has_looped)
<a name="l00429"></a>00429       amplitude_that_reaches_noise_floor = voice-&gt;amplitude_that_reaches_noise_floor_loop;
<a name="l00430"></a>00430     <span class="keywordflow">else</span>
<a name="l00431"></a>00431       amplitude_that_reaches_noise_floor = voice-&gt;amplitude_that_reaches_noise_floor_nonloop;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">/* voice-&gt;attenuation_min is a lower boundary for the attenuation</span>
<a name="l00434"></a>00434 <span class="comment">     * now and in the future (possibly 0 in the worst case).  Now the</span>
<a name="l00435"></a>00435 <span class="comment">     * amplitude of sample and volenv cannot exceed amp_max (since</span>
<a name="l00436"></a>00436 <span class="comment">     * volenv_val can only drop):</span>
<a name="l00437"></a>00437 <span class="comment">     */</span>
<a name="l00438"></a>00438 
<a name="l00439"></a>00439     amp_max = fluid_atten2amp (voice-&gt;min_attenuation_cB) * voice-&gt;volenv_val;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     <span class="comment">/* And if amp_max is already smaller than the known amplitude,</span>
<a name="l00442"></a>00442 <span class="comment">     * which will attenuate the sample below the noise floor, then we</span>
<a name="l00443"></a>00443 <span class="comment">     * can safely turn off the voice. Duh. */</span>
<a name="l00444"></a>00444     <span class="keywordflow">if</span> (amp_max &lt; amplitude_that_reaches_noise_floor)
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446       fluid_profile (FLUID_PROF_VOICE_RELEASE, voice-&gt;ref);
<a name="l00447"></a>00447       fluid_voice_off (voice);
<a name="l00448"></a>00448       <span class="keywordflow">goto</span> post_process;
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450   }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452   <span class="comment">/* Volume increment to go from voice-&gt;amp to target_amp in FLUID_BUFSIZE steps */</span>
<a name="l00453"></a>00453   voice-&gt;amp_incr = (target_amp - voice-&gt;amp) / FLUID_BUFSIZE;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   fluid_check_fpe (<span class="stringliteral">"voice_write amplitude calculation"</span>);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="comment">/* no volume and not changing? - No need to process */</span>
<a name="l00458"></a>00458   <span class="keywordflow">if</span> ((voice-&gt;amp == 0.0f) &amp;&amp; (voice-&gt;amp_incr == 0.0f))
<a name="l00459"></a>00459     <span class="keywordflow">goto</span> post_process;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">/* Calculate the number of samples, that the DSP loop advances</span>
<a name="l00462"></a>00462 <span class="comment">   * through the original waveform with each step in the output</span>
<a name="l00463"></a>00463 <span class="comment">   * buffer. It is the ratio between the frequencies of original</span>
<a name="l00464"></a>00464 <span class="comment">   * waveform and output waveform.*/</span>
<a name="l00465"></a>00465   voice-&gt;phase_incr = fluid_ct2hz_real
<a name="l00466"></a>00466     (voice-&gt;pitch + voice-&gt;modlfo_val * voice-&gt;modlfo_to_pitch
<a name="l00467"></a>00467      + voice-&gt;viblfo_val * voice-&gt;viblfo_to_pitch
<a name="l00468"></a>00468      + voice-&gt;modenv_val * voice-&gt;modenv_to_pitch) / voice-&gt;root_pitch;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   fluid_check_fpe (<span class="stringliteral">"voice_write phase calculation"</span>);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472   <span class="comment">/* if phase_incr is not advancing, set it to the minimum fraction value (prevent stuckage) */</span>
<a name="l00473"></a>00473   <span class="keywordflow">if</span> (voice-&gt;phase_incr == 0) voice-&gt;phase_incr = 1;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475   <span class="comment">/*************** resonant filter ******************/</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <span class="comment">/* calculate the frequency of the resonant filter in Hz */</span>
<a name="l00478"></a>00478   fres = fluid_ct2hz(voice-&gt;fres
<a name="l00479"></a>00479                      + voice-&gt;modlfo_val * voice-&gt;modlfo_to_fc
<a name="l00480"></a>00480                      + voice-&gt;modenv_val * voice-&gt;modenv_to_fc);
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="comment">/* FIXME - Still potential for a click during turn on, can we interpolate</span>
<a name="l00483"></a>00483 <span class="comment">     between 20khz cutoff and 0 Q? */</span>
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="comment">/* I removed the optimization of turning the filter off when the</span>
<a name="l00486"></a>00486 <span class="comment">   * resonance frequence is above the maximum frequency. Instead, the</span>
<a name="l00487"></a>00487 <span class="comment">   * filter frequency is set to a maximum of 0.45 times the sampling</span>
<a name="l00488"></a>00488 <span class="comment">   * rate. For a 44100 kHz sampling rate, this amounts to 19845</span>
<a name="l00489"></a>00489 <span class="comment">   * Hz. The reason is that there were problems with anti-aliasing when the</span>
<a name="l00490"></a>00490 <span class="comment">   * synthesizer was run at lower sampling rates. Thanks to Stephan</span>
<a name="l00491"></a>00491 <span class="comment">   * Tassart for pointing me to this bug. By turning the filter on and</span>
<a name="l00492"></a>00492 <span class="comment">   * clipping the maximum filter frequency at 0.45*srate, the filter</span>
<a name="l00493"></a>00493 <span class="comment">   * is used as an anti-aliasing filter. */</span>
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="keywordflow">if</span> (fres &gt; 0.45f * voice-&gt;output_rate)
<a name="l00496"></a>00496     fres = 0.45f * voice-&gt;output_rate;
<a name="l00497"></a>00497   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fres &lt; 5)
<a name="l00498"></a>00498     fres = 5;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="comment">/* if filter enabled and there is a significant frequency change.. */</span>
<a name="l00501"></a>00501   <span class="keywordflow">if</span> ((abs (fres - voice-&gt;last_fres) &gt; 0.01))
<a name="l00502"></a>00502   {
<a name="l00503"></a>00503     <span class="comment">/* The filter coefficients have to be recalculated (filter</span>
<a name="l00504"></a>00504 <span class="comment">    * parameters have changed). Recalculation for various reasons is</span>
<a name="l00505"></a>00505 <span class="comment">    * forced by setting last_fres to -1.  The flag filter_startup</span>
<a name="l00506"></a>00506 <span class="comment">    * indicates, that the DSP loop runs for the first time, in this</span>
<a name="l00507"></a>00507 <span class="comment">    * case, the filter is set directly, instead of smoothly fading</span>
<a name="l00508"></a>00508 <span class="comment">    * between old and new settings.</span>
<a name="l00509"></a>00509 <span class="comment">    *</span>
<a name="l00510"></a>00510 <span class="comment">    * Those equations from Robert Bristow-Johnson's `Cookbook</span>
<a name="l00511"></a>00511 <span class="comment">    * formulae for audio EQ biquad filter coefficients', obtained</span>
<a name="l00512"></a>00512 <span class="comment">    * from Harmony-central.com / Computer / Programming. They are</span>
<a name="l00513"></a>00513 <span class="comment">    * the result of the bilinear transform on an analogue filter</span>
<a name="l00514"></a>00514 <span class="comment">    * prototype. To quote, `BLT frequency warping has been taken</span>
<a name="l00515"></a>00515 <span class="comment">    * into account for both significant frequency relocation and for</span>
<a name="l00516"></a>00516 <span class="comment">    * bandwidth readjustment'. */</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518    fluid_real_t omega = (fluid_real_t) (2.0 * M_PI * (fres / 44100.0f));
<a name="l00519"></a>00519    fluid_real_t sin_coeff = (fluid_real_t) sin(omega);
<a name="l00520"></a>00520    fluid_real_t cos_coeff = (fluid_real_t) cos(omega);
<a name="l00521"></a>00521    fluid_real_t alpha_coeff = sin_coeff / (2.0f * voice-&gt;q_lin);
<a name="l00522"></a>00522    fluid_real_t a0_inv = 1.0f / (1.0f + alpha_coeff);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524    <span class="comment">/* Calculate the filter coefficients. All coefficients are</span>
<a name="l00525"></a>00525 <span class="comment">    * normalized by a0. Think of `a1' as `a1/a0'.</span>
<a name="l00526"></a>00526 <span class="comment">    *</span>
<a name="l00527"></a>00527 <span class="comment">    * Here a couple of multiplications are saved by reusing common expressions.</span>
<a name="l00528"></a>00528 <span class="comment">    * The original equations should be:</span>
<a name="l00529"></a>00529 <span class="comment">    *  voice-&gt;b0=(1.-cos_coeff)*a0_inv*0.5*voice-&gt;filter_gain;</span>
<a name="l00530"></a>00530 <span class="comment">    *  voice-&gt;b1=(1.-cos_coeff)*a0_inv*voice-&gt;filter_gain;</span>
<a name="l00531"></a>00531 <span class="comment">    *  voice-&gt;b2=(1.-cos_coeff)*a0_inv*0.5*voice-&gt;filter_gain; */</span>
<a name="l00532"></a>00532 
<a name="l00533"></a>00533    fluid_real_t a1_temp = -2.0f * cos_coeff * a0_inv;
<a name="l00534"></a>00534    fluid_real_t a2_temp = (1.0f - alpha_coeff) * a0_inv;
<a name="l00535"></a>00535    fluid_real_t b1_temp = (1.0f - cos_coeff) * a0_inv * voice-&gt;filter_gain;
<a name="l00536"></a>00536    <span class="comment">/* both b0 -and- b2 */</span>
<a name="l00537"></a>00537    fluid_real_t b02_temp = b1_temp * 0.5f;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539    if (voice-&gt;filter_startup)
<a name="l00540"></a>00540    {
<a name="l00541"></a>00541      <span class="comment">/* The filter is calculated, because the voice was started up.</span>
<a name="l00542"></a>00542 <span class="comment">      * In this case set the filter coefficients without delay.</span>
<a name="l00543"></a>00543 <span class="comment">      */</span>
<a name="l00544"></a>00544      voice-&gt;a1 = a1_temp;
<a name="l00545"></a>00545      voice-&gt;a2 = a2_temp;
<a name="l00546"></a>00546      voice-&gt;b02 = b02_temp;
<a name="l00547"></a>00547      voice-&gt;b1 = b1_temp;
<a name="l00548"></a>00548      voice-&gt;filter_coeff_incr_count = 0;
<a name="l00549"></a>00549      voice-&gt;filter_startup = 0;
<a name="l00550"></a>00550 <span class="comment">//       printf("Setting initial filter coefficients.\n");</span>
<a name="l00551"></a>00551    }
<a name="l00552"></a>00552    <span class="keywordflow">else</span>
<a name="l00553"></a>00553    {
<a name="l00554"></a>00554 
<a name="l00555"></a>00555       <span class="comment">/* The filter frequency is changed.  Calculate an increment</span>
<a name="l00556"></a>00556 <span class="comment">       * factor, so that the new setting is reached after one buffer</span>
<a name="l00557"></a>00557 <span class="comment">       * length. x_incr is added to the current value FLUID_BUFSIZE</span>
<a name="l00558"></a>00558 <span class="comment">       * times. The length is arbitrarily chosen. Longer than one</span>
<a name="l00559"></a>00559 <span class="comment">       * buffer will sacrifice some performance, though.  Note: If</span>
<a name="l00560"></a>00560 <span class="comment">       * the filter is still too 'grainy', then increase this number</span>
<a name="l00561"></a>00561 <span class="comment">       * at will.</span>
<a name="l00562"></a>00562 <span class="comment">       */</span>
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="preprocessor">#define FILTER_TRANSITION_SAMPLES (FLUID_BUFSIZE)</span>
<a name="l00565"></a>00565 <span class="preprocessor"></span>
<a name="l00566"></a>00566       voice-&gt;a1_incr = (a1_temp - voice-&gt;a1) / FILTER_TRANSITION_SAMPLES;
<a name="l00567"></a>00567       voice-&gt;a2_incr = (a2_temp - voice-&gt;a2) / FILTER_TRANSITION_SAMPLES;
<a name="l00568"></a>00568       voice-&gt;b02_incr = (b02_temp - voice-&gt;b02) / FILTER_TRANSITION_SAMPLES;
<a name="l00569"></a>00569       voice-&gt;b1_incr = (b1_temp - voice-&gt;b1) / FILTER_TRANSITION_SAMPLES;
<a name="l00570"></a>00570       <span class="comment">/* Have to add the increments filter_coeff_incr_count times. */</span>
<a name="l00571"></a>00571       voice-&gt;filter_coeff_incr_count = FILTER_TRANSITION_SAMPLES;
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573     voice-&gt;last_fres = fres;
<a name="l00574"></a>00574     fluid_check_fpe (<span class="stringliteral">"voice_write filter calculation"</span>);
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   fluid_check_fpe (<span class="stringliteral">"voice_write DSP coefficients"</span>);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   <span class="comment">/*********************** run the dsp chain ************************</span>
<a name="l00581"></a>00581 <span class="comment">   * The sample is mixed with the output buffer.</span>
<a name="l00582"></a>00582 <span class="comment">   * The buffer has to be filled from 0 to FLUID_BUFSIZE-1.</span>
<a name="l00583"></a>00583 <span class="comment">   * Depending on the position in the loop and the loop size, this</span>
<a name="l00584"></a>00584 <span class="comment">   * may require several runs. */</span>
<a name="l00585"></a>00585 
<a name="l00586"></a>00586   voice-&gt;dsp_buf = dsp_buf;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588   <span class="keywordflow">switch</span> (voice-&gt;interp_method)
<a name="l00589"></a>00589   {
<a name="l00590"></a>00590     <span class="keywordflow">case</span> FLUID_INTERP_NONE:
<a name="l00591"></a>00591       count = fluid_dsp_float_interpolate_none (voice);
<a name="l00592"></a>00592       <span class="keywordflow">break</span>;
<a name="l00593"></a>00593     <span class="keywordflow">case</span> FLUID_INTERP_LINEAR:
<a name="l00594"></a>00594       count = fluid_dsp_float_interpolate_linear (voice);
<a name="l00595"></a>00595       <span class="keywordflow">break</span>;
<a name="l00596"></a>00596     <span class="keywordflow">case</span> FLUID_INTERP_4THORDER:
<a name="l00597"></a>00597     <span class="keywordflow">default</span>:
<a name="l00598"></a>00598       count = fluid_dsp_float_interpolate_4th_order (voice);
<a name="l00599"></a>00599       <span class="keywordflow">break</span>;
<a name="l00600"></a>00600     <span class="keywordflow">case</span> FLUID_INTERP_7THORDER:
<a name="l00601"></a>00601       count = fluid_dsp_float_interpolate_7th_order (voice);
<a name="l00602"></a>00602       <span class="keywordflow">break</span>;
<a name="l00603"></a>00603   }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605   fluid_check_fpe (<span class="stringliteral">"voice_write interpolation"</span>);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="keywordflow">if</span> (count &gt; 0)
<a name="l00608"></a>00608     fluid_voice_effects (voice, count, dsp_left_buf, dsp_right_buf,
<a name="l00609"></a>00609                          dsp_reverb_buf, dsp_chorus_buf);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="comment">/* turn off voice if short count (sample ended and not looping) */</span>
<a name="l00612"></a>00612   <span class="keywordflow">if</span> (count &lt; FLUID_BUFSIZE)
<a name="l00613"></a>00613   {
<a name="l00614"></a>00614       fluid_profile(FLUID_PROF_VOICE_RELEASE, voice-&gt;ref);
<a name="l00615"></a>00615       fluid_voice_off(voice);
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618  post_process:
<a name="l00619"></a>00619   voice-&gt;ticks += FLUID_BUFSIZE;
<a name="l00620"></a>00620   fluid_check_fpe (<span class="stringliteral">"voice_write postprocess"</span>);
<a name="l00621"></a>00621   <span class="keywordflow">return</span> FLUID_OK;
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="comment">/* Purpose:</span>
<a name="l00626"></a>00626 <span class="comment"> *</span>
<a name="l00627"></a>00627 <span class="comment"> * - filters (applies a lowpass filter with variable cutoff frequency and quality factor)</span>
<a name="l00628"></a>00628 <span class="comment"> * - mixes the processed sample to left and right output using the pan setting</span>
<a name="l00629"></a>00629 <span class="comment"> * - sends the processed sample to chorus and reverb</span>
<a name="l00630"></a>00630 <span class="comment"> *</span>
<a name="l00631"></a>00631 <span class="comment"> * Variable description:</span>
<a name="l00632"></a>00632 <span class="comment"> * - dsp_data: Pointer to the original waveform data</span>
<a name="l00633"></a>00633 <span class="comment"> * - dsp_left_buf: The generated signal goes here, left channel</span>
<a name="l00634"></a>00634 <span class="comment"> * - dsp_right_buf: right channel</span>
<a name="l00635"></a>00635 <span class="comment"> * - dsp_reverb_buf: Send to reverb unit</span>
<a name="l00636"></a>00636 <span class="comment"> * - dsp_chorus_buf: Send to chorus unit</span>
<a name="l00637"></a>00637 <span class="comment"> * - dsp_a1: Coefficient for the filter</span>
<a name="l00638"></a>00638 <span class="comment"> * - dsp_a2: same</span>
<a name="l00639"></a>00639 <span class="comment"> * - dsp_b0: same</span>
<a name="l00640"></a>00640 <span class="comment"> * - dsp_b1: same</span>
<a name="l00641"></a>00641 <span class="comment"> * - dsp_b2: same</span>
<a name="l00642"></a>00642 <span class="comment"> * - voice holds the voice structure</span>
<a name="l00643"></a>00643 <span class="comment"> *</span>
<a name="l00644"></a>00644 <span class="comment"> * A couple of variables are used internally, their results are discarded:</span>
<a name="l00645"></a>00645 <span class="comment"> * - dsp_i: Index through the output buffer</span>
<a name="l00646"></a>00646 <span class="comment"> * - dsp_phase_fractional: The fractional part of dsp_phase</span>
<a name="l00647"></a>00647 <span class="comment"> * - dsp_coeff: A table of four coefficients, depending on the fractional phase.</span>
<a name="l00648"></a>00648 <span class="comment"> *              Used to interpolate between samples.</span>
<a name="l00649"></a>00649 <span class="comment"> * - dsp_process_buffer: Holds the processed signal between stages</span>
<a name="l00650"></a>00650 <span class="comment"> * - dsp_centernode: delay line for the IIR filter</span>
<a name="l00651"></a>00651 <span class="comment"> * - dsp_hist1: same</span>
<a name="l00652"></a>00652 <span class="comment"> * - dsp_hist2: same</span>
<a name="l00653"></a>00653 <span class="comment"> *</span>
<a name="l00654"></a>00654 <span class="comment"> */</span>
<a name="l00655"></a>00655 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00656"></a>00656 fluid_voice_effects (fluid_voice_t *voice, <span class="keywordtype">int</span> count,
<a name="l00657"></a>00657                      fluid_real_t* dsp_left_buf, fluid_real_t* dsp_right_buf,
<a name="l00658"></a>00658                      fluid_real_t* dsp_reverb_buf, fluid_real_t* dsp_chorus_buf)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660   <span class="comment">/* IIR filter sample history */</span>
<a name="l00661"></a>00661   fluid_real_t dsp_hist1 = voice-&gt;hist1;
<a name="l00662"></a>00662   fluid_real_t dsp_hist2 = voice-&gt;hist2;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="comment">/* IIR filter coefficients */</span>
<a name="l00665"></a>00665   fluid_real_t dsp_a1 = voice-&gt;a1;
<a name="l00666"></a>00666   fluid_real_t dsp_a2 = voice-&gt;a2;
<a name="l00667"></a>00667   fluid_real_t dsp_b02 = voice-&gt;b02;
<a name="l00668"></a>00668   fluid_real_t dsp_b1 = voice-&gt;b1;
<a name="l00669"></a>00669   fluid_real_t dsp_a1_incr = voice-&gt;a1_incr;
<a name="l00670"></a>00670   fluid_real_t dsp_a2_incr = voice-&gt;a2_incr;
<a name="l00671"></a>00671   fluid_real_t dsp_b02_incr = voice-&gt;b02_incr;
<a name="l00672"></a>00672   fluid_real_t dsp_b1_incr = voice-&gt;b1_incr;
<a name="l00673"></a>00673   <span class="keywordtype">int</span> dsp_filter_coeff_incr_count = voice-&gt;filter_coeff_incr_count;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   fluid_real_t *dsp_buf = voice-&gt;dsp_buf;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   fluid_real_t dsp_centernode;
<a name="l00678"></a>00678   <span class="keywordtype">int</span> dsp_i;
<a name="l00679"></a>00679   <span class="keywordtype">float</span> v;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="comment">/* filter (implement the voice filter according to SoundFont standard) */</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="comment">/* Check for denormal number (too close to zero). */</span>
<a name="l00684"></a>00684   <span class="keywordflow">if</span> (fabs (dsp_hist1) &lt; 1e-20) dsp_hist1 = 0.0f;  <span class="comment">/* FIXME JMG - Is this even needed? */</span>
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   <span class="comment">/* Two versions of the filter loop. One, while the filter is</span>
<a name="l00687"></a>00687 <span class="comment">  * changing towards its new setting. The other, if the filter</span>
<a name="l00688"></a>00688 <span class="comment">  * doesn't change.</span>
<a name="l00689"></a>00689 <span class="comment">  */</span>
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   <span class="keywordflow">if</span> (dsp_filter_coeff_incr_count &gt; 0)
<a name="l00692"></a>00692   {
<a name="l00693"></a>00693     <span class="comment">/* Increment is added to each filter coefficient filter_coeff_incr_count times. */</span>
<a name="l00694"></a>00694     <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00695"></a>00695     {
<a name="l00696"></a>00696       <span class="comment">/* The filter is implemented in Direct-II form. */</span>
<a name="l00697"></a>00697       dsp_centernode = dsp_buf[dsp_i] - dsp_a1 * dsp_hist1 - dsp_a2 * dsp_hist2;
<a name="l00698"></a>00698       dsp_buf[dsp_i] = dsp_b02 * (dsp_centernode + dsp_hist2) + dsp_b1 * dsp_hist1;
<a name="l00699"></a>00699       dsp_hist2 = dsp_hist1;
<a name="l00700"></a>00700       dsp_hist1 = dsp_centernode;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702       <span class="keywordflow">if</span> (dsp_filter_coeff_incr_count-- &gt; 0)
<a name="l00703"></a>00703       {
<a name="l00704"></a>00704         dsp_a1 += dsp_a1_incr;
<a name="l00705"></a>00705         dsp_a2 += dsp_a2_incr;
<a name="l00706"></a>00706         dsp_b02 += dsp_b02_incr;
<a name="l00707"></a>00707         dsp_b1 += dsp_b1_incr;
<a name="l00708"></a>00708       }
<a name="l00709"></a>00709     } <span class="comment">/* for dsp_i */</span>
<a name="l00710"></a>00710   }
<a name="l00711"></a>00711   <span class="keywordflow">else</span> <span class="comment">/* The filter parameters are constant.  This is duplicated to save time. */</span>
<a name="l00712"></a>00712   {
<a name="l00713"></a>00713     <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00714"></a>00714     { <span class="comment">/* The filter is implemented in Direct-II form. */</span>
<a name="l00715"></a>00715       dsp_centernode = dsp_buf[dsp_i] - dsp_a1 * dsp_hist1 - dsp_a2 * dsp_hist2;
<a name="l00716"></a>00716       dsp_buf[dsp_i] = dsp_b02 * (dsp_centernode + dsp_hist2) + dsp_b1 * dsp_hist1;
<a name="l00717"></a>00717       dsp_hist2 = dsp_hist1;
<a name="l00718"></a>00718       dsp_hist1 = dsp_centernode;
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720   }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <span class="comment">/* pan (Copy the signal to the left and right output buffer) The voice</span>
<a name="l00723"></a>00723 <span class="comment">  * panning generator has a range of -500 .. 500.  If it is centered,</span>
<a name="l00724"></a>00724 <span class="comment">  * it's close to 0.  voice-&gt;amp_left and voice-&gt;amp_right are then the</span>
<a name="l00725"></a>00725 <span class="comment">  * same, and we can save one multiplication per voice and sample.</span>
<a name="l00726"></a>00726 <span class="comment">  */</span>
<a name="l00727"></a>00727   <span class="keywordflow">if</span> ((-0.5 &lt; voice-&gt;pan) &amp;&amp; (voice-&gt;pan &lt; 0.5))
<a name="l00728"></a>00728   {
<a name="l00729"></a>00729     <span class="comment">/* The voice is centered. Use voice-&gt;amp_left twice. */</span>
<a name="l00730"></a>00730     <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00731"></a>00731     {
<a name="l00732"></a>00732       v = voice-&gt;amp_left * dsp_buf[dsp_i];
<a name="l00733"></a>00733       dsp_left_buf[dsp_i] += v;
<a name="l00734"></a>00734       dsp_right_buf[dsp_i] += v;
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736   }
<a name="l00737"></a>00737   <span class="keywordflow">else</span>  <span class="comment">/* The voice is not centered. Stereo samples have one side zero. */</span>
<a name="l00738"></a>00738   {
<a name="l00739"></a>00739     <span class="keywordflow">if</span> (voice-&gt;amp_left != 0.0)
<a name="l00740"></a>00740     {
<a name="l00741"></a>00741       <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00742"></a>00742         dsp_left_buf[dsp_i] += voice-&gt;amp_left * dsp_buf[dsp_i];
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     <span class="keywordflow">if</span> (voice-&gt;amp_right != 0.0)
<a name="l00746"></a>00746     {
<a name="l00747"></a>00747       <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00748"></a>00748         dsp_right_buf[dsp_i] += voice-&gt;amp_right * dsp_buf[dsp_i];
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750   }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <span class="comment">/* reverb send. Buffer may be NULL. */</span>
<a name="l00753"></a>00753   <span class="keywordflow">if</span> ((dsp_reverb_buf != NULL) &amp;&amp; (voice-&gt;amp_reverb != 0.0))
<a name="l00754"></a>00754   {
<a name="l00755"></a>00755     <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00756"></a>00756       dsp_reverb_buf[dsp_i] += voice-&gt;amp_reverb * dsp_buf[dsp_i];
<a name="l00757"></a>00757   }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759   <span class="comment">/* chorus send. Buffer may be NULL. */</span>
<a name="l00760"></a>00760   <span class="keywordflow">if</span> ((dsp_chorus_buf != NULL) &amp;&amp; (voice-&gt;amp_chorus != 0))
<a name="l00761"></a>00761   {
<a name="l00762"></a>00762     <span class="keywordflow">for</span> (dsp_i = 0; dsp_i &lt; count; dsp_i++)
<a name="l00763"></a>00763       dsp_chorus_buf[dsp_i] += voice-&gt;amp_chorus * dsp_buf[dsp_i];
<a name="l00764"></a>00764   }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   voice-&gt;hist1 = dsp_hist1;
<a name="l00767"></a>00767   voice-&gt;hist2 = dsp_hist2;
<a name="l00768"></a>00768   voice-&gt;a1 = dsp_a1;
<a name="l00769"></a>00769   voice-&gt;a2 = dsp_a2;
<a name="l00770"></a>00770   voice-&gt;b02 = dsp_b02;
<a name="l00771"></a>00771   voice-&gt;b1 = dsp_b1;
<a name="l00772"></a>00772   voice-&gt;filter_coeff_incr_count = dsp_filter_coeff_incr_count;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774   fluid_check_fpe (<span class="stringliteral">"voice_effects"</span>);
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="comment">/*</span>
<a name="l00778"></a>00778 <span class="comment"> * fluid_voice_get_channel</span>
<a name="l00779"></a>00779 <span class="comment"> */</span>
<a name="l00780"></a>00780 fluid_channel_t*
<a name="l00781"></a>00781 fluid_voice_get_channel(fluid_voice_t* voice)
<a name="l00782"></a>00782 {
<a name="l00783"></a>00783   <span class="keywordflow">return</span> voice-&gt;channel;
<a name="l00784"></a>00784 }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="comment">/*</span>
<a name="l00787"></a>00787 <span class="comment"> * fluid_voice_start</span>
<a name="l00788"></a>00788 <span class="comment"> */</span>
<a name="l00789"></a>00789 <span class="keywordtype">void</span> fluid_voice_start(fluid_voice_t* voice)
<a name="l00790"></a>00790 {
<a name="l00791"></a>00791   <span class="comment">/* The maximum volume of the loop is calculated and cached once for each</span>
<a name="l00792"></a>00792 <span class="comment">   * sample with its nominal loop settings. This happens, when the sample is used</span>
<a name="l00793"></a>00793 <span class="comment">   * for the first time.*/</span>
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   fluid_voice_calculate_runtime_synthesis_parameters(voice);
<a name="l00796"></a>00796 
<a name="l00797"></a>00797   <span class="comment">/* Force setting of the phase at the first DSP loop run</span>
<a name="l00798"></a>00798 <span class="comment">   * This cannot be done earlier, because it depends on modulators.*/</span>
<a name="l00799"></a>00799   voice-&gt;check_sample_sanity_flag=FLUID_SAMPLESANITY_STARTUP;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   voice-&gt;ref = fluid_profile_ref();
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   voice-&gt;status = FLUID_VOICE_ON;
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="comment">/*</span>
<a name="l00807"></a>00807 <span class="comment"> * fluid_voice_calculate_runtime_synthesis_parameters</span>
<a name="l00808"></a>00808 <span class="comment"> *</span>
<a name="l00809"></a>00809 <span class="comment"> * in this function we calculate the values of all the parameters. the</span>
<a name="l00810"></a>00810 <span class="comment"> * parameters are converted to their most useful unit for the DSP</span>
<a name="l00811"></a>00811 <span class="comment"> * algorithm, for example, number of samples instead of</span>
<a name="l00812"></a>00812 <span class="comment"> * timecents. Some parameters keep their "perceptual" unit and</span>
<a name="l00813"></a>00813 <span class="comment"> * conversion will be done in the DSP function. This is the case, for</span>
<a name="l00814"></a>00814 <span class="comment"> * example, for the pitch since it is modulated by the controllers in</span>
<a name="l00815"></a>00815 <span class="comment"> * cents. */</span>
<a name="l00816"></a>00816 <span class="keywordtype">int</span>
<a name="l00817"></a>00817 fluid_voice_calculate_runtime_synthesis_parameters(fluid_voice_t* voice)
<a name="l00818"></a>00818 {
<a name="l00819"></a>00819   fluid_real_t x;
<a name="l00820"></a>00820   fluid_real_t q_db;
<a name="l00821"></a>00821   <span class="keywordtype">int</span> i;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="keywordtype">int</span> list_of_generators_to_initialize[35] = {
<a name="l00824"></a>00824     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4446337bebed34df88f998132a5a8492a" title="Sample start address offset (0-32767).">GEN_STARTADDROFS</a>,                    <span class="comment">/* SF2.01 page 48 #0   */</span>
<a name="l00825"></a>00825     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45728b1022388e8e5218383c5f72cf087" title="Sample end address offset (-32767-0).">GEN_ENDADDROFS</a>,                      <span class="comment">/*                #1   */</span>
<a name="l00826"></a>00826     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b423d8f7a3906fa3d8385cea0e1d7119f3" title="Sample loop start address offset (-32767-32767).">GEN_STARTLOOPADDROFS</a>,                <span class="comment">/*                #2   */</span>
<a name="l00827"></a>00827     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4989927f815f1be4e32603719f99b6169" title="Sample loop end address offset (-32767-32767).">GEN_ENDLOOPADDROFS</a>,                  <span class="comment">/*                #3   */</span>
<a name="l00828"></a>00828     <span class="comment">/* GEN_STARTADDRCOARSEOFS see comment below [1]        #4   */</span>
<a name="l00829"></a>00829     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b8343028edd99ad0a23585760bdb1b78" title="Modulation LFO to pitch.">GEN_MODLFOTOPITCH</a>,                   <span class="comment">/*                #5   */</span>
<a name="l00830"></a>00830     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b499387606556a9024de640b4519f7e559" title="Vibrato LFO to pitch.">GEN_VIBLFOTOPITCH</a>,                   <span class="comment">/*                #6   */</span>
<a name="l00831"></a>00831     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c767cd6d4156318428bcfc9b3a2a087c" title="Modulation envelope to pitch.">GEN_MODENVTOPITCH</a>,                   <span class="comment">/*                #7   */</span>
<a name="l00832"></a>00832     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e43e689b0b6349a676d26ea3096ed8d2" title="Filter cutoff.">GEN_FILTERFC</a>,                        <span class="comment">/*                #8   */</span>
<a name="l00833"></a>00833     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4587a7ca42e99238fca39cdf42496af6e" title="Filter Q.">GEN_FILTERQ</a>,                         <span class="comment">/*                #9   */</span>
<a name="l00834"></a>00834     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4dd1b67c6e56efccf734e98da71816315" title="Modulation LFO to filter cutoff.">GEN_MODLFOTOFILTERFC</a>,                <span class="comment">/*                #10  */</span>
<a name="l00835"></a>00835     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b40c51d005b15718a7c7e84addd51073c8" title="Modulation envelope to filter cutoff.">GEN_MODENVTOFILTERFC</a>,                <span class="comment">/*                #11  */</span>
<a name="l00836"></a>00836     <span class="comment">/* GEN_ENDADDRCOARSEOFS [1]                            #12  */</span>
<a name="l00837"></a>00837     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4488cdd7c1a9f15b82a3c317ce5951cc1" title="Modulation LFO to volume.">GEN_MODLFOTOVOL</a>,                     <span class="comment">/*                #13  */</span>
<a name="l00838"></a>00838     <span class="comment">/* not defined                                         #14  */</span>
<a name="l00839"></a>00839     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b420dc580d6c53d30eb97efe3e910793b6" title="Chorus send amount.">GEN_CHORUSSEND</a>,                      <span class="comment">/*                #15  */</span>
<a name="l00840"></a>00840     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48de830acd064933f55e0c1615d1e7f78" title="Reverb send amount.">GEN_REVERBSEND</a>,                      <span class="comment">/*                #16  */</span>
<a name="l00841"></a>00841     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45b713ab8c931017d98f11b5ed5a81fb1" title="Stereo panning.">GEN_PAN</a>,                             <span class="comment">/*                #17  */</span>
<a name="l00842"></a>00842     <span class="comment">/* not defined                                         #18  */</span>
<a name="l00843"></a>00843     <span class="comment">/* not defined                                         #19  */</span>
<a name="l00844"></a>00844     <span class="comment">/* not defined                                         #20  */</span>
<a name="l00845"></a>00845     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b49ea8904d2decc65b0239bd11c9e97250" title="Modulation LFO delay.">GEN_MODLFODELAY</a>,                     <span class="comment">/*                #21  */</span>
<a name="l00846"></a>00846     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b466a660a7b0bebd6d6104dfd8e15b558d" title="Modulation LFO frequency.">GEN_MODLFOFREQ</a>,                      <span class="comment">/*                #22  */</span>
<a name="l00847"></a>00847     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e61bfcf61774784a5e9aeb9865996a0f" title="Vibrato LFO delay.">GEN_VIBLFODELAY</a>,                     <span class="comment">/*                #23  */</span>
<a name="l00848"></a>00848     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e06bcc982faadd741450780989cbd1b0" title="Vibrato LFO frequency.">GEN_VIBLFOFREQ</a>,                      <span class="comment">/*                #24  */</span>
<a name="l00849"></a>00849     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b41dbd9220ed3cdf594dbcc51f2edb888c" title="Modulation envelope delay.">GEN_MODENVDELAY</a>,                     <span class="comment">/*                #25  */</span>
<a name="l00850"></a>00850     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b49ed1b5c95bd9c461558bbf98eb75157d" title="Modulation envelope attack.">GEN_MODENVATTACK</a>,                    <span class="comment">/*                #26  */</span>
<a name="l00851"></a>00851     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b465a52aafce25d202e01ace9c8f170a58" title="Modulation envelope hold.">GEN_MODENVHOLD</a>,                      <span class="comment">/*                #27  */</span>
<a name="l00852"></a>00852     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b495141e243fd2cfd056af89116038bd22" title="Modulation envelope decay.">GEN_MODENVDECAY</a>,                     <span class="comment">/*                #28  */</span>
<a name="l00853"></a>00853     <span class="comment">/* GEN_MODENVSUSTAIN [1]                               #29  */</span>
<a name="l00854"></a>00854     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4d7594c8e4d03e62f7bd5a8770fc6e3d2" title="Modulation envelope release.">GEN_MODENVRELEASE</a>,                   <span class="comment">/*                #30  */</span>
<a name="l00855"></a>00855     <span class="comment">/* GEN_KEYTOMODENVHOLD [1]                             #31  */</span>
<a name="l00856"></a>00856     <span class="comment">/* GEN_KEYTOMODENVDECAY [1]                            #32  */</span>
<a name="l00857"></a>00857     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c4ee056799e46d7877cfb4f244aa6922" title="Volume envelope delay.">GEN_VOLENVDELAY</a>,                     <span class="comment">/*                #33  */</span>
<a name="l00858"></a>00858     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48719daf5507805113f443c16d19b7d64" title="Volume envelope attack.">GEN_VOLENVATTACK</a>,                    <span class="comment">/*                #34  */</span>
<a name="l00859"></a>00859     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4948f8a99eba9400ab3d361ac49a831cb" title="Volume envelope hold.">GEN_VOLENVHOLD</a>,                      <span class="comment">/*                #35  */</span>
<a name="l00860"></a>00860     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4034ca3f2dc95233efbba099ef33d8e51" title="Volume envelope decay.">GEN_VOLENVDECAY</a>,                     <span class="comment">/*                #36  */</span>
<a name="l00861"></a>00861     <span class="comment">/* GEN_VOLENVSUSTAIN [1]                               #37  */</span>
<a name="l00862"></a>00862     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4ca3b587527e748ea7aabb2e3a28e70e7" title="Volume envelope release.">GEN_VOLENVRELEASE</a>,                   <span class="comment">/*                #38  */</span>
<a name="l00863"></a>00863     <span class="comment">/* GEN_KEYTOVOLENVHOLD [1]                             #39  */</span>
<a name="l00864"></a>00864     <span class="comment">/* GEN_KEYTOVOLENVDECAY [1]                            #40  */</span>
<a name="l00865"></a>00865     <span class="comment">/* GEN_STARTLOOPADDRCOARSEOFS [1]                      #45  */</span>
<a name="l00866"></a>00866     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4cb52265c898014662ec34a0bc5e71aab" title="Fixed MIDI note number.">GEN_KEYNUM</a>,                          <span class="comment">/*                #46  */</span>
<a name="l00867"></a>00867     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e94f0b3bf830e3363041e7c9e1d90095" title="Fixed MIDI velocity value.">GEN_VELOCITY</a>,                        <span class="comment">/*                #47  */</span>
<a name="l00868"></a>00868     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b42db65ad593aeff4e814f9a7b7324c0df" title="Initial volume attenuation.">GEN_ATTENUATION</a>,                     <span class="comment">/*                #48  */</span>
<a name="l00869"></a>00869     <span class="comment">/* GEN_ENDLOOPADDRCOARSEOFS [1]                        #50  */</span>
<a name="l00870"></a>00870     <span class="comment">/* GEN_COARSETUNE           [1]                        #51  */</span>
<a name="l00871"></a>00871     <span class="comment">/* GEN_FINETUNE             [1]                        #52  */</span>
<a name="l00872"></a>00872     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4f9dcf53c06eaf19d595685d7fac0f678" title="Sample root note override.">GEN_OVERRIDEROOTKEY</a>,                 <span class="comment">/*                #58  */</span>
<a name="l00873"></a>00873     <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b9a5716b5af1baf131a6225da6687ff0" title="Pitch (NOTE: Not a real SoundFont generator).">GEN_PITCH</a>,                           <span class="comment">/*                ---  */</span>
<a name="l00874"></a>00874     -1};                                 <span class="comment">/* end-of-list marker  */</span>
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="comment">/* When the voice is made ready for the synthesis process, a lot of</span>
<a name="l00877"></a>00877 <span class="comment">   * voice-internal parameters have to be calculated.</span>
<a name="l00878"></a>00878 <span class="comment">   *</span>
<a name="l00879"></a>00879 <span class="comment">   * At this point, the sound font has already set the -nominal- value</span>
<a name="l00880"></a>00880 <span class="comment">   * for all generators (excluding GEN_PITCH). Most generators can be</span>
<a name="l00881"></a>00881 <span class="comment">   * modulated - they include a nominal value and an offset (which</span>
<a name="l00882"></a>00882 <span class="comment">   * changes with velocity, note number, channel parameters like</span>
<a name="l00883"></a>00883 <span class="comment">   * aftertouch, mod wheel...) Now this offset will be calculated as</span>
<a name="l00884"></a>00884 <span class="comment">   * follows:</span>
<a name="l00885"></a>00885 <span class="comment">   *</span>
<a name="l00886"></a>00886 <span class="comment">   *  - Process each modulator once.</span>
<a name="l00887"></a>00887 <span class="comment">   *  - Calculate its output value.</span>
<a name="l00888"></a>00888 <span class="comment">   *  - Find the target generator.</span>
<a name="l00889"></a>00889 <span class="comment">   *  - Add the output value to the modulation value of the generator.</span>
<a name="l00890"></a>00890 <span class="comment">   *</span>
<a name="l00891"></a>00891 <span class="comment">   * Note: The generators have been initialized with</span>
<a name="l00892"></a>00892 <span class="comment">   * fluid_gen_set_default_values.</span>
<a name="l00893"></a>00893 <span class="comment">   */</span>
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   <span class="keywordflow">for</span> (i = 0; i &lt; voice-&gt;mod_count; i++) {
<a name="l00896"></a>00896     <a class="code" href="struct__fluid__mod__t.html">fluid_mod_t</a>* mod = &amp;voice-&gt;mod[i];
<a name="l00897"></a>00897     fluid_real_t modval = fluid_mod_get_value(mod, voice-&gt;channel, voice);
<a name="l00898"></a>00898     <span class="keywordtype">int</span> dest_gen_index = mod-&gt;<a class="code" href="struct__fluid__mod__t.html#1c7d15ae9ad239b578701878b0ffbb08">dest</a>;
<a name="l00899"></a>00899     <a class="code" href="structfluid__gen__t.html" title="SoundFont generator structure.">fluid_gen_t</a>* dest_gen = &amp;voice-&gt;gen[dest_gen_index];
<a name="l00900"></a>00900     dest_gen-&gt;<a class="code" href="structfluid__gen__t.html#dae65a465c3bd8e4e92d7ecbecd0e03d" title="Change by modulators.">mod</a> += modval;
<a name="l00901"></a>00901     <span class="comment">/*      fluid_dump_modulator(mod); */</span>
<a name="l00902"></a>00902   }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="comment">/* The GEN_PITCH is a hack to fit the pitch bend controller into the</span>
<a name="l00905"></a>00905 <span class="comment">   * modulator paradigm.  Now the nominal pitch of the key is set.</span>
<a name="l00906"></a>00906 <span class="comment">   * Note about SCALETUNE: SF2.01 8.1.3 says, that this generator is a</span>
<a name="l00907"></a>00907 <span class="comment">   * non-realtime parameter. So we don't allow modulation (as opposed</span>
<a name="l00908"></a>00908 <span class="comment">   * to _GEN(voice, GEN_SCALETUNE) When the scale tuning is varied,</span>
<a name="l00909"></a>00909 <span class="comment">   * one key remains fixed. Here C3 (MIDI number 60) is used.</span>
<a name="l00910"></a>00910 <span class="comment">   */</span>
<a name="l00911"></a>00911   <span class="keywordflow">if</span> (fluid_channel_has_tuning(voice-&gt;channel)) {
<a name="l00912"></a>00912     <span class="comment">/* pitch(60) + scale * (pitch(key) - pitch(60)) */</span>
<a name="l00913"></a>00913 <span class="preprocessor">    #define __pitch(_k) fluid_tuning_get_pitch(tuning, _k)</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span>    fluid_tuning_t* tuning = fluid_channel_get_tuning(voice-&gt;channel);
<a name="l00915"></a>00915     voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b9a5716b5af1baf131a6225da6687ff0" title="Pitch (NOTE: Not a real SoundFont generator).">GEN_PITCH</a>].val = (__pitch(60) + (voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48d2c25fc136b28599eb551b761a6a24f" title="Scale tuning.">GEN_SCALETUNE</a>].val / 100.0f *
<a name="l00916"></a>00916                                            (__pitch(voice-&gt;key) - __pitch(60))));
<a name="l00917"></a>00917   } <span class="keywordflow">else</span> {
<a name="l00918"></a>00918     voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b9a5716b5af1baf131a6225da6687ff0" title="Pitch (NOTE: Not a real SoundFont generator).">GEN_PITCH</a>].val = (voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48d2c25fc136b28599eb551b761a6a24f" title="Scale tuning.">GEN_SCALETUNE</a>].val * (voice-&gt;key - 60.0f)
<a name="l00919"></a>00919                                  + 100.0f * 60.0f);
<a name="l00920"></a>00920   }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922   <span class="comment">/* Now the generators are initialized, nominal and modulation value.</span>
<a name="l00923"></a>00923 <span class="comment">   * The voice parameters (which depend on generators) are calculated</span>
<a name="l00924"></a>00924 <span class="comment">   * with fluid_voice_update_param. Processing the list of generator</span>
<a name="l00925"></a>00925 <span class="comment">   * changes will calculate each voice parameter once.</span>
<a name="l00926"></a>00926 <span class="comment">   *</span>
<a name="l00927"></a>00927 <span class="comment">   * Note [1]: Some voice parameters depend on several generators. For</span>
<a name="l00928"></a>00928 <span class="comment">   * example, the pitch depends on GEN_COARSETUNE, GEN_FINETUNE and</span>
<a name="l00929"></a>00929 <span class="comment">   * GEN_PITCH.  voice-&gt;pitch.  Unnecessary recalculation is avoided</span>
<a name="l00930"></a>00930 <span class="comment">   * by removing all but one generator from the list of voice</span>
<a name="l00931"></a>00931 <span class="comment">   * parameters.  Same with GEN_XXX and GEN_XXXCOARSE: the</span>
<a name="l00932"></a>00932 <span class="comment">   * initialisation list contains only GEN_XXX.</span>
<a name="l00933"></a>00933 <span class="comment">   */</span>
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   <span class="comment">/* Calculate the voice parameter(s) dependent on each generator. */</span>
<a name="l00936"></a>00936   <span class="keywordflow">for</span> (i = 0; list_of_generators_to_initialize[i] != -1; i++) {
<a name="l00937"></a>00937     fluid_voice_update_param(voice, list_of_generators_to_initialize[i]);
<a name="l00938"></a>00938   }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940   <span class="comment">/* Make an estimate on how loud this voice can get at any time (attenuation). */</span>
<a name="l00941"></a>00941   voice-&gt;min_attenuation_cB = fluid_voice_get_lower_boundary_for_attenuation(voice);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943   <span class="keywordflow">return</span> FLUID_OK;
<a name="l00944"></a>00944 }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 <span class="comment">/*</span>
<a name="l00947"></a>00947 <span class="comment"> * calculate_hold_decay_buffers</span>
<a name="l00948"></a>00948 <span class="comment"> */</span>
<a name="l00949"></a>00949 <span class="keywordtype">int</span> calculate_hold_decay_buffers(fluid_voice_t* voice, <span class="keywordtype">int</span> gen_base,
<a name="l00950"></a>00950                                  <span class="keywordtype">int</span> gen_key2base, <span class="keywordtype">int</span> is_decay)
<a name="l00951"></a>00951 {
<a name="l00952"></a>00952   <span class="comment">/* Purpose:</span>
<a name="l00953"></a>00953 <span class="comment">   *</span>
<a name="l00954"></a>00954 <span class="comment">   * Returns the number of DSP loops, that correspond to the hold</span>
<a name="l00955"></a>00955 <span class="comment">   * (is_decay=0) or decay (is_decay=1) time.</span>
<a name="l00956"></a>00956 <span class="comment">   * gen_base=GEN_VOLENVHOLD, GEN_VOLENVDECAY, GEN_MODENVHOLD,</span>
<a name="l00957"></a>00957 <span class="comment">   * GEN_MODENVDECAY gen_key2base=GEN_KEYTOVOLENVHOLD,</span>
<a name="l00958"></a>00958 <span class="comment">   * GEN_KEYTOVOLENVDECAY, GEN_KEYTOMODENVHOLD, GEN_KEYTOMODENVDECAY</span>
<a name="l00959"></a>00959 <span class="comment">   */</span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961   fluid_real_t timecents;
<a name="l00962"></a>00962   fluid_real_t seconds;
<a name="l00963"></a>00963   <span class="keywordtype">int</span> buffers;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <span class="comment">/* SF2.01 section 8.4.3 # 31, 32, 39, 40</span>
<a name="l00966"></a>00966 <span class="comment">   * GEN_KEYTOxxxENVxxx uses key 60 as 'origin'.</span>
<a name="l00967"></a>00967 <span class="comment">   * The unit of the generator is timecents per key number.</span>
<a name="l00968"></a>00968 <span class="comment">   * If KEYTOxxxENVxxx is 100, a key one octave over key 60 (72)</span>
<a name="l00969"></a>00969 <span class="comment">   * will cause (60-72)*100=-1200 timecents of time variation.</span>
<a name="l00970"></a>00970 <span class="comment">   * The time is cut in half.</span>
<a name="l00971"></a>00971 <span class="comment">   */</span>
<a name="l00972"></a>00972   timecents = (_GEN(voice, gen_base) + _GEN(voice, gen_key2base) * (60.0 - voice-&gt;key));
<a name="l00973"></a>00973 
<a name="l00974"></a>00974   <span class="comment">/* Range checking */</span>
<a name="l00975"></a>00975   <span class="keywordflow">if</span> (is_decay){
<a name="l00976"></a>00976     <span class="comment">/* SF 2.01 section 8.1.3 # 28, 36 */</span>
<a name="l00977"></a>00977     <span class="keywordflow">if</span> (timecents &gt; 8000.0) {
<a name="l00978"></a>00978       timecents = 8000.0;
<a name="l00979"></a>00979     }
<a name="l00980"></a>00980   } <span class="keywordflow">else</span> {
<a name="l00981"></a>00981     <span class="comment">/* SF 2.01 section 8.1.3 # 27, 35 */</span>
<a name="l00982"></a>00982     <span class="keywordflow">if</span> (timecents &gt; 5000) {
<a name="l00983"></a>00983       timecents = 5000.0;
<a name="l00984"></a>00984     }
<a name="l00985"></a>00985     <span class="comment">/* SF 2.01 section 8.1.2 # 27, 35:</span>
<a name="l00986"></a>00986 <span class="comment">     * The most negative number indicates no hold time</span>
<a name="l00987"></a>00987 <span class="comment">     */</span>
<a name="l00988"></a>00988     <span class="keywordflow">if</span> (timecents &lt;= -32768.) {
<a name="l00989"></a>00989       <span class="keywordflow">return</span> 0;
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991   }
<a name="l00992"></a>00992   <span class="comment">/* SF 2.01 section 8.1.3 # 27, 28, 35, 36 */</span>
<a name="l00993"></a>00993   <span class="keywordflow">if</span> (timecents &lt; -12000.0) {
<a name="l00994"></a>00994     timecents = -12000.0;
<a name="l00995"></a>00995   }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997   seconds = fluid_tc2sec(timecents);
<a name="l00998"></a>00998   <span class="comment">/* Each DSP loop processes FLUID_BUFSIZE samples. */</span>
<a name="l00999"></a>00999 
<a name="l01000"></a>01000   <span class="comment">/* round to next full number of buffers */</span>
<a name="l01001"></a>01001   buffers = (int)(((fluid_real_t)voice-&gt;output_rate * seconds)
<a name="l01002"></a>01002                   / (fluid_real_t)FLUID_BUFSIZE
<a name="l01003"></a>01003                   +0.5);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   <span class="keywordflow">return</span> buffers;
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="comment">/*</span>
<a name="l01009"></a>01009 <span class="comment"> * fluid_voice_update_param</span>
<a name="l01010"></a>01010 <span class="comment"> *</span>
<a name="l01011"></a>01011 <span class="comment"> * Purpose:</span>
<a name="l01012"></a>01012 <span class="comment"> *</span>
<a name="l01013"></a>01013 <span class="comment"> * The value of a generator (gen) has changed.  (The different</span>
<a name="l01014"></a>01014 <span class="comment"> * generators are listed in fluidsynth.h, or in SF2.01 page 48-49)</span>
<a name="l01015"></a>01015 <span class="comment"> * Now the dependent 'voice' parameters are calculated.</span>
<a name="l01016"></a>01016 <span class="comment"> *</span>
<a name="l01017"></a>01017 <span class="comment"> * fluid_voice_update_param can be called during the setup of the</span>
<a name="l01018"></a>01018 <span class="comment"> * voice (to calculate the initial value for a voice parameter), or</span>
<a name="l01019"></a>01019 <span class="comment"> * during its operation (a generator has been changed due to</span>
<a name="l01020"></a>01020 <span class="comment"> * real-time parameter modifications like pitch-bend).</span>
<a name="l01021"></a>01021 <span class="comment"> *</span>
<a name="l01022"></a>01022 <span class="comment"> * Note: The generator holds three values: The base value .val, an</span>
<a name="l01023"></a>01023 <span class="comment"> * offset caused by modulators .mod, and an offset caused by the</span>
<a name="l01024"></a>01024 <span class="comment"> * NRPN system. _GEN(voice, generator_enumerator) returns the sum</span>
<a name="l01025"></a>01025 <span class="comment"> * of all three.</span>
<a name="l01026"></a>01026 <span class="comment"> */</span>
<a name="l01027"></a>01027 <span class="keywordtype">void</span>
<a name="l01028"></a>01028 fluid_voice_update_param(fluid_voice_t* voice, <span class="keywordtype">int</span> gen)
<a name="l01029"></a>01029 {
<a name="l01030"></a>01030   <span class="keywordtype">double</span> q_dB;
<a name="l01031"></a>01031   fluid_real_t x;
<a name="l01032"></a>01032   fluid_real_t y;
<a name="l01033"></a>01033   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   <span class="keywordflow">switch</span> (gen) {
<a name="l01036"></a>01036 
<a name="l01037"></a>01037   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45b713ab8c931017d98f11b5ed5a81fb1" title="Stereo panning.">GEN_PAN</a>:
<a name="l01038"></a>01038     <span class="comment">/* range checking is done in the fluid_pan function */</span>
<a name="l01039"></a>01039     voice-&gt;pan = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45b713ab8c931017d98f11b5ed5a81fb1" title="Stereo panning.">GEN_PAN</a>);
<a name="l01040"></a>01040     voice-&gt;amp_left = fluid_pan(voice-&gt;pan, 1) * voice-&gt;synth_gain / 32768.0f;
<a name="l01041"></a>01041     voice-&gt;amp_right = fluid_pan(voice-&gt;pan, 0) * voice-&gt;synth_gain / 32768.0f;
<a name="l01042"></a>01042     <span class="keywordflow">break</span>;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b42db65ad593aeff4e814f9a7b7324c0df" title="Initial volume attenuation.">GEN_ATTENUATION</a>:
<a name="l01045"></a>01045     voice-&gt;attenuation = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b42db65ad593aeff4e814f9a7b7324c0df" title="Initial volume attenuation.">GEN_ATTENUATION</a>);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047     <span class="comment">/* Range: SF2.01 section 8.1.3 # 48</span>
<a name="l01048"></a>01048 <span class="comment">     * Motivation for range checking:</span>
<a name="l01049"></a>01049 <span class="comment">     * OHPiano.SF2 sets initial attenuation to a whooping -96 dB */</span>
<a name="l01050"></a>01050     fluid_clip(voice-&gt;attenuation, 0.0, 1440.0);
<a name="l01051"></a>01051     <span class="keywordflow">break</span>;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     <span class="comment">/* The pitch is calculated from three different generators.</span>
<a name="l01054"></a>01054 <span class="comment">     * Read comment in fluidsynth.h about GEN_PITCH.</span>
<a name="l01055"></a>01055 <span class="comment">     */</span>
<a name="l01056"></a>01056   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b9a5716b5af1baf131a6225da6687ff0" title="Pitch (NOTE: Not a real SoundFont generator).">GEN_PITCH</a>:
<a name="l01057"></a>01057   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45ffa8b961965bad3ec420e049e399c33" title="Coarse tuning.">GEN_COARSETUNE</a>:
<a name="l01058"></a>01058   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b468229fec83f8d5d62246d98c6868320d" title="Fine tuning.">GEN_FINETUNE</a>:
<a name="l01059"></a>01059     <span class="comment">/* The testing for allowed range is done in 'fluid_ct2hz' */</span>
<a name="l01060"></a>01060     voice-&gt;pitch = (_GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b9a5716b5af1baf131a6225da6687ff0" title="Pitch (NOTE: Not a real SoundFont generator).">GEN_PITCH</a>)
<a name="l01061"></a>01061                     + 100.0f * _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45ffa8b961965bad3ec420e049e399c33" title="Coarse tuning.">GEN_COARSETUNE</a>)
<a name="l01062"></a>01062                     + _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b468229fec83f8d5d62246d98c6868320d" title="Fine tuning.">GEN_FINETUNE</a>));
<a name="l01063"></a>01063     <span class="keywordflow">break</span>;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48de830acd064933f55e0c1615d1e7f78" title="Reverb send amount.">GEN_REVERBSEND</a>:
<a name="l01066"></a>01066     <span class="comment">/* The generator unit is 'tenths of a percent'. */</span>
<a name="l01067"></a>01067     voice-&gt;reverb_send = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48de830acd064933f55e0c1615d1e7f78" title="Reverb send amount.">GEN_REVERBSEND</a>) / 1000.0f;
<a name="l01068"></a>01068     fluid_clip(voice-&gt;reverb_send, 0.0, 1.0);
<a name="l01069"></a>01069     voice-&gt;amp_reverb = voice-&gt;reverb_send * voice-&gt;synth_gain / 32768.0f;
<a name="l01070"></a>01070     <span class="keywordflow">break</span>;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b420dc580d6c53d30eb97efe3e910793b6" title="Chorus send amount.">GEN_CHORUSSEND</a>:
<a name="l01073"></a>01073     <span class="comment">/* The generator unit is 'tenths of a percent'. */</span>
<a name="l01074"></a>01074     voice-&gt;chorus_send = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b420dc580d6c53d30eb97efe3e910793b6" title="Chorus send amount.">GEN_CHORUSSEND</a>) / 1000.0f;
<a name="l01075"></a>01075     fluid_clip(voice-&gt;chorus_send, 0.0, 1.0);
<a name="l01076"></a>01076     voice-&gt;amp_chorus = voice-&gt;chorus_send * voice-&gt;synth_gain / 32768.0f;
<a name="l01077"></a>01077     <span class="keywordflow">break</span>;
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4f9dcf53c06eaf19d595685d7fac0f678" title="Sample root note override.">GEN_OVERRIDEROOTKEY</a>:
<a name="l01080"></a>01080     <span class="comment">/* This is a non-realtime parameter. Therefore the .mod part of the generator</span>
<a name="l01081"></a>01081 <span class="comment">     * can be neglected.</span>
<a name="l01082"></a>01082 <span class="comment">     * NOTE: origpitch sets MIDI root note while pitchadj is a fine tuning amount</span>
<a name="l01083"></a>01083 <span class="comment">     * which offsets the original rate.  This means that the fine tuning is</span>
<a name="l01084"></a>01084 <span class="comment">     * inverted with respect to the root note (so subtract it, not add).</span>
<a name="l01085"></a>01085 <span class="comment">     */</span>
<a name="l01086"></a>01086     <span class="keywordflow">if</span> (voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4f9dcf53c06eaf19d595685d7fac0f678" title="Sample root note override.">GEN_OVERRIDEROOTKEY</a>].val &gt; -1) {   <span class="comment">//FIXME: use flag instead of -1</span>
<a name="l01087"></a>01087       voice-&gt;root_pitch = voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4f9dcf53c06eaf19d595685d7fac0f678" title="Sample root note override.">GEN_OVERRIDEROOTKEY</a>].val * 100.0f
<a name="l01088"></a>01088         - voice-&gt;sample-&gt;pitchadj;
<a name="l01089"></a>01089     } <span class="keywordflow">else</span> {
<a name="l01090"></a>01090       voice-&gt;root_pitch = voice-&gt;sample-&gt;origpitch * 100.0f - voice-&gt;sample-&gt;pitchadj;
<a name="l01091"></a>01091     }
<a name="l01092"></a>01092     voice-&gt;root_pitch = fluid_ct2hz(voice-&gt;root_pitch);
<a name="l01093"></a>01093     <span class="keywordflow">if</span> (voice-&gt;sample != NULL) {
<a name="l01094"></a>01094       voice-&gt;root_pitch *= (fluid_real_t) voice-&gt;output_rate / voice-&gt;sample-&gt;samplerate;
<a name="l01095"></a>01095     }
<a name="l01096"></a>01096     <span class="keywordflow">break</span>;
<a name="l01097"></a>01097 
<a name="l01098"></a>01098   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e43e689b0b6349a676d26ea3096ed8d2" title="Filter cutoff.">GEN_FILTERFC</a>:
<a name="l01099"></a>01099     <span class="comment">/* The resonance frequency is converted from absolute cents to</span>
<a name="l01100"></a>01100 <span class="comment">     * midicents .val and .mod are both used, this permits real-time</span>
<a name="l01101"></a>01101 <span class="comment">     * modulation.  The allowed range is tested in the 'fluid_ct2hz'</span>
<a name="l01102"></a>01102 <span class="comment">     * function [PH,20021214]</span>
<a name="l01103"></a>01103 <span class="comment">     */</span>
<a name="l01104"></a>01104     voice-&gt;fres = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e43e689b0b6349a676d26ea3096ed8d2" title="Filter cutoff.">GEN_FILTERFC</a>);
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="comment">/* The synthesis loop will have to recalculate the filter</span>
<a name="l01107"></a>01107 <span class="comment">     * coefficients. */</span>
<a name="l01108"></a>01108     voice-&gt;last_fres = -1.0f;
<a name="l01109"></a>01109     <span class="keywordflow">break</span>;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4587a7ca42e99238fca39cdf42496af6e" title="Filter Q.">GEN_FILTERQ</a>:
<a name="l01112"></a>01112     <span class="comment">/* The generator contains 'centibels' (1/10 dB) =&gt; divide by 10 to</span>
<a name="l01113"></a>01113 <span class="comment">     * obtain dB */</span>
<a name="l01114"></a>01114     q_dB = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4587a7ca42e99238fca39cdf42496af6e" title="Filter Q.">GEN_FILTERQ</a>) / 10.0f;
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="comment">/* Range: SF2.01 section 8.1.3 # 8 (convert from cB to dB =&gt; /10) */</span>
<a name="l01117"></a>01117     fluid_clip(q_dB, 0.0f, 96.0f);
<a name="l01118"></a>01118 
<a name="l01119"></a>01119     <span class="comment">/* Short version: Modify the Q definition in a way, that a Q of 0</span>
<a name="l01120"></a>01120 <span class="comment">     * dB leads to no resonance hump in the freq. response.</span>
<a name="l01121"></a>01121 <span class="comment">     *</span>
<a name="l01122"></a>01122 <span class="comment">     * Long version: From SF2.01, page 39, item 9 (initialFilterQ):</span>
<a name="l01123"></a>01123 <span class="comment">     * "The gain at the cutoff frequency may be less than zero when</span>
<a name="l01124"></a>01124 <span class="comment">     * zero is specified".  Assume q_dB=0 / q_lin=1: If we would leave</span>
<a name="l01125"></a>01125 <span class="comment">     * q as it is, then this results in a 3 dB hump slightly below</span>
<a name="l01126"></a>01126 <span class="comment">     * fc. At fc, the gain is exactly the DC gain (0 dB).  What is</span>
<a name="l01127"></a>01127 <span class="comment">     * (probably) meant here is that the filter does not show a</span>
<a name="l01128"></a>01128 <span class="comment">     * resonance hump for q_dB=0. In this case, the corresponding</span>
<a name="l01129"></a>01129 <span class="comment">     * q_lin is 1/sqrt(2)=0.707.  The filter should have 3 dB of</span>
<a name="l01130"></a>01130 <span class="comment">     * attenuation at fc now.  In this case Q_dB is the height of the</span>
<a name="l01131"></a>01131 <span class="comment">     * resonance peak not over the DC gain, but over the frequency</span>
<a name="l01132"></a>01132 <span class="comment">     * response of a non-resonant filter.  This idea is implemented as</span>
<a name="l01133"></a>01133 <span class="comment">     * follows: */</span>
<a name="l01134"></a>01134     q_dB -= 3.01f;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136     <span class="comment">/* The 'sound font' Q is defined in dB. The filter needs a linear</span>
<a name="l01137"></a>01137 <span class="comment">       q. Convert. */</span>
<a name="l01138"></a>01138     voice-&gt;q_lin = (fluid_real_t) (pow(10.0f, q_dB / 20.0f));
<a name="l01139"></a>01139 
<a name="l01140"></a>01140     <span class="comment">/* SF 2.01 page 59:</span>
<a name="l01141"></a>01141 <span class="comment">     *</span>
<a name="l01142"></a>01142 <span class="comment">     *  The SoundFont specs ask for a gain reduction equal to half the</span>
<a name="l01143"></a>01143 <span class="comment">     *  height of the resonance peak (Q).  For example, for a 10 dB</span>
<a name="l01144"></a>01144 <span class="comment">     *  resonance peak, the gain is reduced by 5 dB.  This is done by</span>
<a name="l01145"></a>01145 <span class="comment">     *  multiplying the total gain with sqrt(1/Q).  `Sqrt' divides dB</span>
<a name="l01146"></a>01146 <span class="comment">     *  by 2 (100 lin = 40 dB, 10 lin = 20 dB, 3.16 lin = 10 dB etc)</span>
<a name="l01147"></a>01147 <span class="comment">     *  The gain is later factored into the 'b' coefficients</span>
<a name="l01148"></a>01148 <span class="comment">     *  (numerator of the filter equation).  This gain factor depends</span>
<a name="l01149"></a>01149 <span class="comment">     *  only on Q, so this is the right place to calculate it.</span>
<a name="l01150"></a>01150 <span class="comment">     */</span>
<a name="l01151"></a>01151     voice-&gt;filter_gain = (fluid_real_t) (1.0 / sqrt(voice-&gt;q_lin));
<a name="l01152"></a>01152 
<a name="l01153"></a>01153     <span class="comment">/* The synthesis loop will have to recalculate the filter coefficients. */</span>
<a name="l01154"></a>01154     voice-&gt;last_fres = -1.;
<a name="l01155"></a>01155     <span class="keywordflow">break</span>;
<a name="l01156"></a>01156 
<a name="l01157"></a>01157   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b8343028edd99ad0a23585760bdb1b78" title="Modulation LFO to pitch.">GEN_MODLFOTOPITCH</a>:
<a name="l01158"></a>01158     voice-&gt;modlfo_to_pitch = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4b8343028edd99ad0a23585760bdb1b78" title="Modulation LFO to pitch.">GEN_MODLFOTOPITCH</a>);
<a name="l01159"></a>01159     fluid_clip(voice-&gt;modlfo_to_pitch, -12000.0, 12000.0);
<a name="l01160"></a>01160     <span class="keywordflow">break</span>;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4488cdd7c1a9f15b82a3c317ce5951cc1" title="Modulation LFO to volume.">GEN_MODLFOTOVOL</a>:
<a name="l01163"></a>01163     voice-&gt;modlfo_to_vol = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4488cdd7c1a9f15b82a3c317ce5951cc1" title="Modulation LFO to volume.">GEN_MODLFOTOVOL</a>);
<a name="l01164"></a>01164     fluid_clip(voice-&gt;modlfo_to_vol, -960.0, 960.0);
<a name="l01165"></a>01165     <span class="keywordflow">break</span>;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4dd1b67c6e56efccf734e98da71816315" title="Modulation LFO to filter cutoff.">GEN_MODLFOTOFILTERFC</a>:
<a name="l01168"></a>01168     voice-&gt;modlfo_to_fc = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4dd1b67c6e56efccf734e98da71816315" title="Modulation LFO to filter cutoff.">GEN_MODLFOTOFILTERFC</a>);
<a name="l01169"></a>01169     fluid_clip(voice-&gt;modlfo_to_fc, -12000, 12000);
<a name="l01170"></a>01170     <span class="keywordflow">break</span>;
<a name="l01171"></a>01171 
<a name="l01172"></a>01172   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b49ea8904d2decc65b0239bd11c9e97250" title="Modulation LFO delay.">GEN_MODLFODELAY</a>:
<a name="l01173"></a>01173     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b49ea8904d2decc65b0239bd11c9e97250" title="Modulation LFO delay.">GEN_MODLFODELAY</a>);
<a name="l01174"></a>01174     fluid_clip(x, -12000.0f, 5000.0f);
<a name="l01175"></a>01175     voice-&gt;modlfo_delay = (<span class="keywordtype">unsigned</span> int) (voice-&gt;output_rate * fluid_tc2sec_delay(x));
<a name="l01176"></a>01176     <span class="keywordflow">break</span>;
<a name="l01177"></a>01177 
<a name="l01178"></a>01178   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b466a660a7b0bebd6d6104dfd8e15b558d" title="Modulation LFO frequency.">GEN_MODLFOFREQ</a>:
<a name="l01179"></a>01179     <span class="comment">/* - the frequency is converted into a delta value, per buffer of FLUID_BUFSIZE samples</span>
<a name="l01180"></a>01180 <span class="comment">     * - the delay into a sample delay</span>
<a name="l01181"></a>01181 <span class="comment">     */</span>
<a name="l01182"></a>01182     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b466a660a7b0bebd6d6104dfd8e15b558d" title="Modulation LFO frequency.">GEN_MODLFOFREQ</a>);
<a name="l01183"></a>01183     fluid_clip(x, -16000.0f, 4500.0f);
<a name="l01184"></a>01184     voice-&gt;modlfo_incr = (4.0f * FLUID_BUFSIZE * fluid_act2hz(x) / voice-&gt;output_rate);
<a name="l01185"></a>01185     <span class="keywordflow">break</span>;
<a name="l01186"></a>01186 
<a name="l01187"></a>01187   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e06bcc982faadd741450780989cbd1b0" title="Vibrato LFO frequency.">GEN_VIBLFOFREQ</a>:
<a name="l01188"></a>01188     <span class="comment">/* vib lfo</span>
<a name="l01189"></a>01189 <span class="comment">     *</span>
<a name="l01190"></a>01190 <span class="comment">     * - the frequency is converted into a delta value, per buffer of FLUID_BUFSIZE samples</span>
<a name="l01191"></a>01191 <span class="comment">     * - the delay into a sample delay</span>
<a name="l01192"></a>01192 <span class="comment">     */</span>
<a name="l01193"></a>01193     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e06bcc982faadd741450780989cbd1b0" title="Vibrato LFO frequency.">GEN_VIBLFOFREQ</a>);
<a name="l01194"></a>01194     fluid_clip(x, -16000.0f, 4500.0f);
<a name="l01195"></a>01195     voice-&gt;viblfo_incr = (4.0f * FLUID_BUFSIZE * fluid_act2hz(x) / voice-&gt;output_rate);
<a name="l01196"></a>01196     <span class="keywordflow">break</span>;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e61bfcf61774784a5e9aeb9865996a0f" title="Vibrato LFO delay.">GEN_VIBLFODELAY</a>:
<a name="l01199"></a>01199     x = _GEN(voice,<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e61bfcf61774784a5e9aeb9865996a0f" title="Vibrato LFO delay.">GEN_VIBLFODELAY</a>);
<a name="l01200"></a>01200     fluid_clip(x, -12000.0f, 5000.0f);
<a name="l01201"></a>01201     voice-&gt;viblfo_delay = (<span class="keywordtype">unsigned</span> int) (voice-&gt;output_rate * fluid_tc2sec_delay(x));
<a name="l01202"></a>01202     <span class="keywordflow">break</span>;
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b499387606556a9024de640b4519f7e559" title="Vibrato LFO to pitch.">GEN_VIBLFOTOPITCH</a>:
<a name="l01205"></a>01205     voice-&gt;viblfo_to_pitch = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b499387606556a9024de640b4519f7e559" title="Vibrato LFO to pitch.">GEN_VIBLFOTOPITCH</a>);
<a name="l01206"></a>01206     fluid_clip(voice-&gt;viblfo_to_pitch, -12000.0, 12000.0);
<a name="l01207"></a>01207     <span class="keywordflow">break</span>;
<a name="l01208"></a>01208 
<a name="l01209"></a>01209   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4cb52265c898014662ec34a0bc5e71aab" title="Fixed MIDI note number.">GEN_KEYNUM</a>:
<a name="l01210"></a>01210     <span class="comment">/* GEN_KEYNUM: SF2.01 page 46, item 46</span>
<a name="l01211"></a>01211 <span class="comment">     *</span>
<a name="l01212"></a>01212 <span class="comment">     * If this generator is active, it forces the key number to its</span>
<a name="l01213"></a>01213 <span class="comment">     * value.  Non-realtime controller.</span>
<a name="l01214"></a>01214 <span class="comment">     *</span>
<a name="l01215"></a>01215 <span class="comment">     * There is a flag, which should indicate, whether a generator is</span>
<a name="l01216"></a>01216 <span class="comment">     * enabled or not.  But here we rely on the default value of -1.</span>
<a name="l01217"></a>01217 <span class="comment">     * */</span>
<a name="l01218"></a>01218     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4cb52265c898014662ec34a0bc5e71aab" title="Fixed MIDI note number.">GEN_KEYNUM</a>);
<a name="l01219"></a>01219     <span class="keywordflow">if</span> (x &gt;= 0){
<a name="l01220"></a>01220       voice-&gt;key = x;
<a name="l01221"></a>01221     }
<a name="l01222"></a>01222     <span class="keywordflow">break</span>;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e94f0b3bf830e3363041e7c9e1d90095" title="Fixed MIDI velocity value.">GEN_VELOCITY</a>:
<a name="l01225"></a>01225     <span class="comment">/* GEN_VELOCITY: SF2.01 page 46, item 47</span>
<a name="l01226"></a>01226 <span class="comment">     *</span>
<a name="l01227"></a>01227 <span class="comment">     * If this generator is active, it forces the velocity to its</span>
<a name="l01228"></a>01228 <span class="comment">     * value. Non-realtime controller.</span>
<a name="l01229"></a>01229 <span class="comment">     *</span>
<a name="l01230"></a>01230 <span class="comment">     * There is a flag, which should indicate, whether a generator is</span>
<a name="l01231"></a>01231 <span class="comment">     * enabled or not. But here we rely on the default value of -1.  */</span>
<a name="l01232"></a>01232     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e94f0b3bf830e3363041e7c9e1d90095" title="Fixed MIDI velocity value.">GEN_VELOCITY</a>);
<a name="l01233"></a>01233     <span class="keywordflow">if</span> (x &gt; 0) {
<a name="l01234"></a>01234       voice-&gt;vel = x;
<a name="l01235"></a>01235     }
<a name="l01236"></a>01236     <span class="keywordflow">break</span>;
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c767cd6d4156318428bcfc9b3a2a087c" title="Modulation envelope to pitch.">GEN_MODENVTOPITCH</a>:
<a name="l01239"></a>01239     voice-&gt;modenv_to_pitch = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c767cd6d4156318428bcfc9b3a2a087c" title="Modulation envelope to pitch.">GEN_MODENVTOPITCH</a>);
<a name="l01240"></a>01240     fluid_clip(voice-&gt;modenv_to_pitch, -12000.0, 12000.0);
<a name="l01241"></a>01241     <span class="keywordflow">break</span>;
<a name="l01242"></a>01242 
<a name="l01243"></a>01243   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b40c51d005b15718a7c7e84addd51073c8" title="Modulation envelope to filter cutoff.">GEN_MODENVTOFILTERFC</a>:
<a name="l01244"></a>01244     voice-&gt;modenv_to_fc = _GEN(voice,<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b40c51d005b15718a7c7e84addd51073c8" title="Modulation envelope to filter cutoff.">GEN_MODENVTOFILTERFC</a>);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     <span class="comment">/* Range: SF2.01 section 8.1.3 # 1</span>
<a name="l01247"></a>01247 <span class="comment">     * Motivation for range checking:</span>
<a name="l01248"></a>01248 <span class="comment">     * Filter is reported to make funny noises now and then</span>
<a name="l01249"></a>01249 <span class="comment">     */</span>
<a name="l01250"></a>01250     fluid_clip(voice-&gt;modenv_to_fc, -12000.0, 12000.0);
<a name="l01251"></a>01251     <span class="keywordflow">break</span>;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="comment">/* sample start and ends points</span>
<a name="l01255"></a>01255 <span class="comment">     *</span>
<a name="l01256"></a>01256 <span class="comment">     * Range checking is initiated via the</span>
<a name="l01257"></a>01257 <span class="comment">     * voice-&gt;check_sample_sanity flag,</span>
<a name="l01258"></a>01258 <span class="comment">     * because it is impossible to check here:</span>
<a name="l01259"></a>01259 <span class="comment">     * During the voice setup, all modulators are processed, while</span>
<a name="l01260"></a>01260 <span class="comment">     * the voice is inactive. Therefore, illegal settings may</span>
<a name="l01261"></a>01261 <span class="comment">     * occur during the setup (for example: First move the loop</span>
<a name="l01262"></a>01262 <span class="comment">     * end point ahead of the loop start point =&gt; invalid, then</span>
<a name="l01263"></a>01263 <span class="comment">     * move the loop start point forward =&gt; valid again.</span>
<a name="l01264"></a>01264 <span class="comment">     */</span>
<a name="l01265"></a>01265   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4446337bebed34df88f998132a5a8492a" title="Sample start address offset (0-32767).">GEN_STARTADDROFS</a>:              <span class="comment">/* SF2.01 section 8.1.3 # 0 */</span>
<a name="l01266"></a>01266   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c60e7883e31e05f35202eba013e33030" title="Sample start address coarse offset (X 32768).">GEN_STARTADDRCOARSEOFS</a>:        <span class="comment">/* SF2.01 section 8.1.3 # 4 */</span>
<a name="l01267"></a>01267     <span class="keywordflow">if</span> (voice-&gt;sample != NULL) {
<a name="l01268"></a>01268       voice-&gt;start = (voice-&gt;sample-&gt;start
<a name="l01269"></a>01269                              + (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4446337bebed34df88f998132a5a8492a" title="Sample start address offset (0-32767).">GEN_STARTADDROFS</a>)
<a name="l01270"></a>01270                              + 32768 * (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c60e7883e31e05f35202eba013e33030" title="Sample start address coarse offset (X 32768).">GEN_STARTADDRCOARSEOFS</a>));
<a name="l01271"></a>01271       voice-&gt;check_sample_sanity_flag = FLUID_SAMPLESANITY_CHECK;
<a name="l01272"></a>01272     }
<a name="l01273"></a>01273     <span class="keywordflow">break</span>;
<a name="l01274"></a>01274   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45728b1022388e8e5218383c5f72cf087" title="Sample end address offset (-32767-0).">GEN_ENDADDROFS</a>:                 <span class="comment">/* SF2.01 section 8.1.3 # 1 */</span>
<a name="l01275"></a>01275   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b44795d4f36d830b51ba20af142cd17625" title="Sample end address coarse offset (X 32768).">GEN_ENDADDRCOARSEOFS</a>:           <span class="comment">/* SF2.01 section 8.1.3 # 12 */</span>
<a name="l01276"></a>01276     <span class="keywordflow">if</span> (voice-&gt;sample != NULL) {
<a name="l01277"></a>01277       voice-&gt;end = (voice-&gt;sample-&gt;end
<a name="l01278"></a>01278                            + (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45728b1022388e8e5218383c5f72cf087" title="Sample end address offset (-32767-0).">GEN_ENDADDROFS</a>)
<a name="l01279"></a>01279                            + 32768 * (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b44795d4f36d830b51ba20af142cd17625" title="Sample end address coarse offset (X 32768).">GEN_ENDADDRCOARSEOFS</a>));
<a name="l01280"></a>01280       voice-&gt;check_sample_sanity_flag = FLUID_SAMPLESANITY_CHECK;
<a name="l01281"></a>01281     }
<a name="l01282"></a>01282     <span class="keywordflow">break</span>;
<a name="l01283"></a>01283   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b423d8f7a3906fa3d8385cea0e1d7119f3" title="Sample loop start address offset (-32767-32767).">GEN_STARTLOOPADDROFS</a>:           <span class="comment">/* SF2.01 section 8.1.3 # 2 */</span>
<a name="l01284"></a>01284   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b41746f056035cc6e4ed07161a7259bbe6" title="Sample start loop address coarse offset (X 32768).">GEN_STARTLOOPADDRCOARSEOFS</a>:     <span class="comment">/* SF2.01 section 8.1.3 # 45 */</span>
<a name="l01285"></a>01285     <span class="keywordflow">if</span> (voice-&gt;sample != NULL) {
<a name="l01286"></a>01286       voice-&gt;loopstart = (voice-&gt;sample-&gt;loopstart
<a name="l01287"></a>01287                                   + (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b423d8f7a3906fa3d8385cea0e1d7119f3" title="Sample loop start address offset (-32767-32767).">GEN_STARTLOOPADDROFS</a>)
<a name="l01288"></a>01288                                   + 32768 * (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b41746f056035cc6e4ed07161a7259bbe6" title="Sample start loop address coarse offset (X 32768).">GEN_STARTLOOPADDRCOARSEOFS</a>));
<a name="l01289"></a>01289       voice-&gt;check_sample_sanity_flag = FLUID_SAMPLESANITY_CHECK;
<a name="l01290"></a>01290     }
<a name="l01291"></a>01291     <span class="keywordflow">break</span>;
<a name="l01292"></a>01292 
<a name="l01293"></a>01293   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4989927f815f1be4e32603719f99b6169" title="Sample loop end address offset (-32767-32767).">GEN_ENDLOOPADDROFS</a>:             <span class="comment">/* SF2.01 section 8.1.3 # 3 */</span>
<a name="l01294"></a>01294   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e57660306a59b9547798d52ce90bb4bb" title="Sample end loop address coarse offset (X 32768).">GEN_ENDLOOPADDRCOARSEOFS</a>:       <span class="comment">/* SF2.01 section 8.1.3 # 50 */</span>
<a name="l01295"></a>01295     <span class="keywordflow">if</span> (voice-&gt;sample != NULL) {
<a name="l01296"></a>01296       voice-&gt;loopend = (voice-&gt;sample-&gt;loopend
<a name="l01297"></a>01297                                 + (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4989927f815f1be4e32603719f99b6169" title="Sample loop end address offset (-32767-32767).">GEN_ENDLOOPADDROFS</a>)
<a name="l01298"></a>01298                                 + 32768 * (int) _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4e57660306a59b9547798d52ce90bb4bb" title="Sample end loop address coarse offset (X 32768).">GEN_ENDLOOPADDRCOARSEOFS</a>));
<a name="l01299"></a>01299       voice-&gt;check_sample_sanity_flag = FLUID_SAMPLESANITY_CHECK;
<a name="l01300"></a>01300     }
<a name="l01301"></a>01301     <span class="keywordflow">break</span>;
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="comment">/* Conversion functions differ in range limit */</span>
<a name="l01304"></a>01304 <span class="preprocessor">#define NUM_BUFFERS_DELAY(_v)   (unsigned int) (voice-&gt;output_rate * fluid_tc2sec_delay(_v) / FLUID_BUFSIZE)</span>
<a name="l01305"></a>01305 <span class="preprocessor"></span><span class="preprocessor">#define NUM_BUFFERS_ATTACK(_v)  (unsigned int) (voice-&gt;output_rate * fluid_tc2sec_attack(_v) / FLUID_BUFSIZE)</span>
<a name="l01306"></a>01306 <span class="preprocessor"></span><span class="preprocessor">#define NUM_BUFFERS_RELEASE(_v) (unsigned int) (voice-&gt;output_rate * fluid_tc2sec_release(_v) / FLUID_BUFSIZE)</span>
<a name="l01307"></a>01307 <span class="preprocessor"></span>
<a name="l01308"></a>01308     <span class="comment">/* volume envelope</span>
<a name="l01309"></a>01309 <span class="comment">     *</span>
<a name="l01310"></a>01310 <span class="comment">     * - delay and hold times are converted to absolute number of samples</span>
<a name="l01311"></a>01311 <span class="comment">     * - sustain is converted to its absolute value</span>
<a name="l01312"></a>01312 <span class="comment">     * - attack, decay and release are converted to their increment per sample</span>
<a name="l01313"></a>01313 <span class="comment">     */</span>
<a name="l01314"></a>01314   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c4ee056799e46d7877cfb4f244aa6922" title="Volume envelope delay.">GEN_VOLENVDELAY</a>:                <span class="comment">/* SF2.01 section 8.1.3 # 33 */</span>
<a name="l01315"></a>01315     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4c4ee056799e46d7877cfb4f244aa6922" title="Volume envelope delay.">GEN_VOLENVDELAY</a>);
<a name="l01316"></a>01316     fluid_clip(x, -12000.0f, 5000.0f);
<a name="l01317"></a>01317     count = NUM_BUFFERS_DELAY(x);
<a name="l01318"></a>01318     voice-&gt;volenv_data[FLUID_VOICE_ENVDELAY].count = count;
<a name="l01319"></a>01319     voice-&gt;volenv_data[FLUID_VOICE_ENVDELAY].coeff = 0.0f;
<a name="l01320"></a>01320     voice-&gt;volenv_data[FLUID_VOICE_ENVDELAY].incr = 0.0f;
<a name="l01321"></a>01321     voice-&gt;volenv_data[FLUID_VOICE_ENVDELAY].min = -1.0f;
<a name="l01322"></a>01322     voice-&gt;volenv_data[FLUID_VOICE_ENVDELAY].max = 1.0f;
<a name="l01323"></a>01323     <span class="keywordflow">break</span>;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48719daf5507805113f443c16d19b7d64" title="Volume envelope attack.">GEN_VOLENVATTACK</a>:               <span class="comment">/* SF2.01 section 8.1.3 # 34 */</span>
<a name="l01326"></a>01326     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b48719daf5507805113f443c16d19b7d64" title="Volume envelope attack.">GEN_VOLENVATTACK</a>);
<a name="l01327"></a>01327     fluid_clip(x, -12000.0f, 8000.0f);
<a name="l01328"></a>01328     count = 1 + NUM_BUFFERS_ATTACK(x);
<a name="l01329"></a>01329     voice-&gt;volenv_data[FLUID_VOICE_ENVATTACK].count = count;
<a name="l01330"></a>01330     voice-&gt;volenv_data[FLUID_VOICE_ENVATTACK].coeff = 1.0f;
<a name="l01331"></a>01331     voice-&gt;volenv_data[FLUID_VOICE_ENVATTACK].incr = count ? 1.0f / count : 0.0f;
<a name="l01332"></a>01332     voice-&gt;volenv_data[FLUID_VOICE_ENVATTACK].min = -1.0f;
<a name="l01333"></a>01333     voice-&gt;volenv_data[FLUID_VOICE_ENVATTACK].max = 1.0f;
<a name="l01334"></a>01334     <span class="keywordflow">break</span>;
<a name="l01335"></a>01335 
<a name="l01336"></a>01336   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4948f8a99eba9400ab3d361ac49a831cb" title="Volume envelope hold.">GEN_VOLENVHOLD</a>:                 <span class="comment">/* SF2.01 section 8.1.3 # 35 */</span>
<a name="l01337"></a>01337   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4bb0287401874a3e223f9a79b50c29e6a" title="Key to volume envelope hold.">GEN_KEYTOVOLENVHOLD</a>:            <span class="comment">/* SF2.01 section 8.1.3 # 39 */</span>
<a name="l01338"></a>01338     count = calculate_hold_decay_buffers(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4948f8a99eba9400ab3d361ac49a831cb" title="Volume envelope hold.">GEN_VOLENVHOLD</a>, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4bb0287401874a3e223f9a79b50c29e6a" title="Key to volume envelope hold.">GEN_KEYTOVOLENVHOLD</a>, 0); <span class="comment">/* 0 means: hold */</span>
<a name="l01339"></a>01339     voice-&gt;volenv_data[FLUID_VOICE_ENVHOLD].count = count;
<a name="l01340"></a>01340     voice-&gt;volenv_data[FLUID_VOICE_ENVHOLD].coeff = 1.0f;
<a name="l01341"></a>01341     voice-&gt;volenv_data[FLUID_VOICE_ENVHOLD].incr = 0.0f;
<a name="l01342"></a>01342     voice-&gt;volenv_data[FLUID_VOICE_ENVHOLD].min = -1.0f;
<a name="l01343"></a>01343     voice-&gt;volenv_data[FLUID_VOICE_ENVHOLD].max = 2.0f;
<a name="l01344"></a>01344     <span class="keywordflow">break</span>;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4034ca3f2dc95233efbba099ef33d8e51" title="Volume envelope decay.">GEN_VOLENVDECAY</a>:               <span class="comment">/* SF2.01 section 8.1.3 # 36 */</span>
<a name="l01347"></a>01347   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b40741e826d8acb00bde4810ec07c3bcd0" title="Volume envelope sustain.">GEN_VOLENVSUSTAIN</a>:             <span class="comment">/* SF2.01 section 8.1.3 # 37 */</span>
<a name="l01348"></a>01348   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b472ec6209fab9decf6ed9cb5283cdc019" title="Key to volume envelope decay.">GEN_KEYTOVOLENVDECAY</a>:          <span class="comment">/* SF2.01 section 8.1.3 # 40 */</span>
<a name="l01349"></a>01349     y = 1.0f - 0.001f * _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b40741e826d8acb00bde4810ec07c3bcd0" title="Volume envelope sustain.">GEN_VOLENVSUSTAIN</a>);
<a name="l01350"></a>01350     fluid_clip(y, 0.0f, 1.0f);
<a name="l01351"></a>01351     count = calculate_hold_decay_buffers(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4034ca3f2dc95233efbba099ef33d8e51" title="Volume envelope decay.">GEN_VOLENVDECAY</a>, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b472ec6209fab9decf6ed9cb5283cdc019" title="Key to volume envelope decay.">GEN_KEYTOVOLENVDECAY</a>, 1); <span class="comment">/* 1 for decay */</span>
<a name="l01352"></a>01352     voice-&gt;volenv_data[FLUID_VOICE_ENVDECAY].count = count;
<a name="l01353"></a>01353     voice-&gt;volenv_data[FLUID_VOICE_ENVDECAY].coeff = 1.0f;
<a name="l01354"></a>01354     voice-&gt;volenv_data[FLUID_VOICE_ENVDECAY].incr = count ? -1.0f / count : 0.0f;
<a name="l01355"></a>01355     voice-&gt;volenv_data[FLUID_VOICE_ENVDECAY].min = y;
<a name="l01356"></a>01356     voice-&gt;volenv_data[FLUID_VOICE_ENVDECAY].max = 2.0f;
<a name="l01357"></a>01357     <span class="keywordflow">break</span>;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4ca3b587527e748ea7aabb2e3a28e70e7" title="Volume envelope release.">GEN_VOLENVRELEASE</a>:             <span class="comment">/* SF2.01 section 8.1.3 # 38 */</span>
<a name="l01360"></a>01360     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4ca3b587527e748ea7aabb2e3a28e70e7" title="Volume envelope release.">GEN_VOLENVRELEASE</a>);
<a name="l01361"></a>01361     fluid_clip(x, FLUID_MIN_VOLENVRELEASE, 8000.0f);
<a name="l01362"></a>01362     count = 1 + NUM_BUFFERS_RELEASE(x);
<a name="l01363"></a>01363     voice-&gt;volenv_data[FLUID_VOICE_ENVRELEASE].count = count;
<a name="l01364"></a>01364     voice-&gt;volenv_data[FLUID_VOICE_ENVRELEASE].coeff = 1.0f;
<a name="l01365"></a>01365     voice-&gt;volenv_data[FLUID_VOICE_ENVRELEASE].incr = count ? -1.0f / count : 0.0f;
<a name="l01366"></a>01366     voice-&gt;volenv_data[FLUID_VOICE_ENVRELEASE].min = 0.0f;
<a name="l01367"></a>01367     voice-&gt;volenv_data[FLUID_VOICE_ENVRELEASE].max = 1.0f;
<a name="l01368"></a>01368     <span class="keywordflow">break</span>;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     <span class="comment">/* Modulation envelope */</span>
<a name="l01371"></a>01371   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b41dbd9220ed3cdf594dbcc51f2edb888c" title="Modulation envelope delay.">GEN_MODENVDELAY</a>:               <span class="comment">/* SF2.01 section 8.1.3 # 25 */</span>
<a name="l01372"></a>01372     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b41dbd9220ed3cdf594dbcc51f2edb888c" title="Modulation envelope delay.">GEN_MODENVDELAY</a>);
<a name="l01373"></a>01373     fluid_clip(x, -12000.0f, 5000.0f);
<a name="l01374"></a>01374     voice-&gt;modenv_data[FLUID_VOICE_ENVDELAY].count = NUM_BUFFERS_DELAY(x);
<a name="l01375"></a>01375     voice-&gt;modenv_data[FLUID_VOICE_ENVDELAY].coeff = 0.0f;
<a name="l01376"></a>01376     voice-&gt;modenv_data[FLUID_VOICE_ENVDELAY].incr = 0.0f;
<a name="l01377"></a>01377     voice-&gt;modenv_data[FLUID_VOICE_ENVDELAY].min = -1.0f;
<a name="l01378"></a>01378     voice-&gt;modenv_data[FLUID_VOICE_ENVDELAY].max = 1.0f;
<a name="l01379"></a>01379     <span class="keywordflow">break</span>;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b49ed1b5c95bd9c461558bbf98eb75157d" title="Modulation envelope attack.">GEN_MODENVATTACK</a>:               <span class="comment">/* SF2.01 section 8.1.3 # 26 */</span>
<a name="l01382"></a>01382     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b49ed1b5c95bd9c461558bbf98eb75157d" title="Modulation envelope attack.">GEN_MODENVATTACK</a>);
<a name="l01383"></a>01383     fluid_clip(x, -12000.0f, 8000.0f);
<a name="l01384"></a>01384     count = 1 + NUM_BUFFERS_ATTACK(x);
<a name="l01385"></a>01385     voice-&gt;modenv_data[FLUID_VOICE_ENVATTACK].count = count;
<a name="l01386"></a>01386     voice-&gt;modenv_data[FLUID_VOICE_ENVATTACK].coeff = 1.0f;
<a name="l01387"></a>01387     voice-&gt;modenv_data[FLUID_VOICE_ENVATTACK].incr = count ? 1.0f / count : 0.0f;
<a name="l01388"></a>01388     voice-&gt;modenv_data[FLUID_VOICE_ENVATTACK].min = -1.0f;
<a name="l01389"></a>01389     voice-&gt;modenv_data[FLUID_VOICE_ENVATTACK].max = 1.0f;
<a name="l01390"></a>01390     <span class="keywordflow">break</span>;
<a name="l01391"></a>01391 
<a name="l01392"></a>01392   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b465a52aafce25d202e01ace9c8f170a58" title="Modulation envelope hold.">GEN_MODENVHOLD</a>:               <span class="comment">/* SF2.01 section 8.1.3 # 27 */</span>
<a name="l01393"></a>01393   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4da2d2d053e33b9b54870bc7b6b18c4c3" title="Key to modulation envelope hold.">GEN_KEYTOMODENVHOLD</a>:          <span class="comment">/* SF2.01 section 8.1.3 # 31 */</span>
<a name="l01394"></a>01394     count = calculate_hold_decay_buffers(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b465a52aafce25d202e01ace9c8f170a58" title="Modulation envelope hold.">GEN_MODENVHOLD</a>, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4da2d2d053e33b9b54870bc7b6b18c4c3" title="Key to modulation envelope hold.">GEN_KEYTOMODENVHOLD</a>, 0); <span class="comment">/* 1 means: hold */</span>
<a name="l01395"></a>01395     voice-&gt;modenv_data[FLUID_VOICE_ENVHOLD].count = count;
<a name="l01396"></a>01396     voice-&gt;modenv_data[FLUID_VOICE_ENVHOLD].coeff = 1.0f;
<a name="l01397"></a>01397     voice-&gt;modenv_data[FLUID_VOICE_ENVHOLD].incr = 0.0f;
<a name="l01398"></a>01398     voice-&gt;modenv_data[FLUID_VOICE_ENVHOLD].min = -1.0f;
<a name="l01399"></a>01399     voice-&gt;modenv_data[FLUID_VOICE_ENVHOLD].max = 2.0f;
<a name="l01400"></a>01400     <span class="keywordflow">break</span>;
<a name="l01401"></a>01401 
<a name="l01402"></a>01402   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b495141e243fd2cfd056af89116038bd22" title="Modulation envelope decay.">GEN_MODENVDECAY</a>:                                   <span class="comment">/* SF 2.01 section 8.1.3 # 28 */</span>
<a name="l01403"></a>01403   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4a8216db47eb4508e8f810da36a3e3199" title="Modulation envelope sustain.">GEN_MODENVSUSTAIN</a>:                                 <span class="comment">/* SF 2.01 section 8.1.3 # 29 */</span>
<a name="l01404"></a>01404   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b46f26ca6855cfb526ff0d550a98a1e07a" title="Key to modulation envelope decay.">GEN_KEYTOMODENVDECAY</a>:                              <span class="comment">/* SF 2.01 section 8.1.3 # 32 */</span>
<a name="l01405"></a>01405     count = calculate_hold_decay_buffers(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b495141e243fd2cfd056af89116038bd22" title="Modulation envelope decay.">GEN_MODENVDECAY</a>, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b46f26ca6855cfb526ff0d550a98a1e07a" title="Key to modulation envelope decay.">GEN_KEYTOMODENVDECAY</a>, 1); <span class="comment">/* 1 for decay */</span>
<a name="l01406"></a>01406     y = 1.0f - 0.001f * _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4a8216db47eb4508e8f810da36a3e3199" title="Modulation envelope sustain.">GEN_MODENVSUSTAIN</a>);
<a name="l01407"></a>01407     fluid_clip(y, 0.0f, 1.0f);
<a name="l01408"></a>01408     voice-&gt;modenv_data[FLUID_VOICE_ENVDECAY].count = count;
<a name="l01409"></a>01409     voice-&gt;modenv_data[FLUID_VOICE_ENVDECAY].coeff = 1.0f;
<a name="l01410"></a>01410     voice-&gt;modenv_data[FLUID_VOICE_ENVDECAY].incr = count ? -1.0f / count : 0.0f;
<a name="l01411"></a>01411     voice-&gt;modenv_data[FLUID_VOICE_ENVDECAY].min = y;
<a name="l01412"></a>01412     voice-&gt;modenv_data[FLUID_VOICE_ENVDECAY].max = 2.0f;
<a name="l01413"></a>01413     <span class="keywordflow">break</span>;
<a name="l01414"></a>01414 
<a name="l01415"></a>01415   <span class="keywordflow">case</span> <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4d7594c8e4d03e62f7bd5a8770fc6e3d2" title="Modulation envelope release.">GEN_MODENVRELEASE</a>:                                  <span class="comment">/* SF 2.01 section 8.1.3 # 30 */</span>
<a name="l01416"></a>01416     x = _GEN(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4d7594c8e4d03e62f7bd5a8770fc6e3d2" title="Modulation envelope release.">GEN_MODENVRELEASE</a>);
<a name="l01417"></a>01417     fluid_clip(x, -12000.0f, 8000.0f);
<a name="l01418"></a>01418     count = 1 + NUM_BUFFERS_RELEASE(x);
<a name="l01419"></a>01419     voice-&gt;modenv_data[FLUID_VOICE_ENVRELEASE].count = count;
<a name="l01420"></a>01420     voice-&gt;modenv_data[FLUID_VOICE_ENVRELEASE].coeff = 1.0f;
<a name="l01421"></a>01421     voice-&gt;modenv_data[FLUID_VOICE_ENVRELEASE].incr = count ? -1.0f / count : 0.0;
<a name="l01422"></a>01422     voice-&gt;modenv_data[FLUID_VOICE_ENVRELEASE].min = 0.0f;
<a name="l01423"></a>01423     voice-&gt;modenv_data[FLUID_VOICE_ENVRELEASE].max = 2.0f;
<a name="l01424"></a>01424     <span class="keywordflow">break</span>;
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   } <span class="comment">/* switch gen */</span>
<a name="l01427"></a>01427 }
<a name="l01428"></a>01428 
<a name="l01456"></a>01456 <span class="keywordtype">int</span> fluid_voice_modulate(fluid_voice_t* voice, <span class="keywordtype">int</span> cc, <span class="keywordtype">int</span> ctrl)
<a name="l01457"></a>01457 {
<a name="l01458"></a>01458   <span class="keywordtype">int</span> i, k;
<a name="l01459"></a>01459   <a class="code" href="struct__fluid__mod__t.html">fluid_mod_t</a>* mod;
<a name="l01460"></a>01460   <span class="keywordtype">int</span> gen;
<a name="l01461"></a>01461   fluid_real_t modval;
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="comment">/*    printf("Chan=%d, CC=%d, Src=%d, Val=%d\n", voice-&gt;channel-&gt;channum, cc, ctrl, val); */</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   <span class="keywordflow">for</span> (i = 0; i &lt; voice-&gt;mod_count; i++) {
<a name="l01466"></a>01466 
<a name="l01467"></a>01467     mod = &amp;voice-&gt;mod[i];
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     <span class="comment">/* step 1: find all the modulators that have the changed controller</span>
<a name="l01470"></a>01470 <span class="comment">     * as input source. */</span>
<a name="l01471"></a>01471     <span class="keywordflow">if</span> (fluid_mod_has_source(mod, cc, ctrl)) {
<a name="l01472"></a>01472 
<a name="l01473"></a>01473       gen = fluid_mod_get_dest(mod);
<a name="l01474"></a>01474       modval = 0.0;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476       <span class="comment">/* step 2: for every changed modulator, calculate the modulation</span>
<a name="l01477"></a>01477 <span class="comment">       * value of its associated generator */</span>
<a name="l01478"></a>01478       <span class="keywordflow">for</span> (k = 0; k &lt; voice-&gt;mod_count; k++) {
<a name="l01479"></a>01479         <span class="keywordflow">if</span> (fluid_mod_has_dest(&amp;voice-&gt;mod[k], gen)) {
<a name="l01480"></a>01480           modval += fluid_mod_get_value(&amp;voice-&gt;mod[k], voice-&gt;channel, voice);
<a name="l01481"></a>01481         }
<a name="l01482"></a>01482       }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484       fluid_gen_set_mod(&amp;voice-&gt;gen[gen], modval);
<a name="l01485"></a>01485 
<a name="l01486"></a>01486       <span class="comment">/* step 3: now that we have the new value of the generator,</span>
<a name="l01487"></a>01487 <span class="comment">       * recalculate the parameter values that are derived from the</span>
<a name="l01488"></a>01488 <span class="comment">       * generator */</span>
<a name="l01489"></a>01489       fluid_voice_update_param(voice, gen);
<a name="l01490"></a>01490     }
<a name="l01491"></a>01491   }
<a name="l01492"></a>01492   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01493"></a>01493 }
<a name="l01494"></a>01494 
<a name="l01502"></a>01502 <span class="keywordtype">int</span> fluid_voice_modulate_all(fluid_voice_t* voice)
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504   <a class="code" href="struct__fluid__mod__t.html">fluid_mod_t</a>* mod;
<a name="l01505"></a>01505   <span class="keywordtype">int</span> i, k, gen;
<a name="l01506"></a>01506   fluid_real_t modval;
<a name="l01507"></a>01507 
<a name="l01508"></a>01508   <span class="comment">/* Loop through all the modulators.</span>
<a name="l01509"></a>01509 <span class="comment"></span>
<a name="l01510"></a>01510 <span class="comment">     FIXME: we should loop through the set of generators instead of</span>
<a name="l01511"></a>01511 <span class="comment">     the set of modulators. We risk to call 'fluid_voice_update_param'</span>
<a name="l01512"></a>01512 <span class="comment">     several times for the same generator if several modulators have</span>
<a name="l01513"></a>01513 <span class="comment">     that generator as destination. It's not an error, just a wast of</span>
<a name="l01514"></a>01514 <span class="comment">     energy (think polution, global warming, unhappy musicians,</span>
<a name="l01515"></a>01515 <span class="comment">     ...) */</span>
<a name="l01516"></a>01516 
<a name="l01517"></a>01517   <span class="keywordflow">for</span> (i = 0; i &lt; voice-&gt;mod_count; i++) {
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     mod = &amp;voice-&gt;mod[i];
<a name="l01520"></a>01520     gen = fluid_mod_get_dest(mod);
<a name="l01521"></a>01521     modval = 0.0;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523     <span class="comment">/* Accumulate the modulation values of all the modulators with</span>
<a name="l01524"></a>01524 <span class="comment">     * destination generator 'gen' */</span>
<a name="l01525"></a>01525     <span class="keywordflow">for</span> (k = 0; k &lt; voice-&gt;mod_count; k++) {
<a name="l01526"></a>01526       <span class="keywordflow">if</span> (fluid_mod_has_dest(&amp;voice-&gt;mod[k], gen)) {
<a name="l01527"></a>01527         modval += fluid_mod_get_value(&amp;voice-&gt;mod[k], voice-&gt;channel, voice);
<a name="l01528"></a>01528       }
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     fluid_gen_set_mod(&amp;voice-&gt;gen[gen], modval);
<a name="l01532"></a>01532 
<a name="l01533"></a>01533     <span class="comment">/* Update the parameter values that are depend on the generator</span>
<a name="l01534"></a>01534 <span class="comment">     * 'gen' */</span>
<a name="l01535"></a>01535     fluid_voice_update_param(voice, gen);
<a name="l01536"></a>01536   }
<a name="l01537"></a>01537 
<a name="l01538"></a>01538   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01539"></a>01539 }
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 <span class="comment">/*</span>
<a name="l01542"></a>01542 <span class="comment"> * fluid_voice_noteoff</span>
<a name="l01543"></a>01543 <span class="comment"> */</span>
<a name="l01544"></a>01544 <span class="keywordtype">int</span>
<a name="l01545"></a>01545 fluid_voice_noteoff(fluid_voice_t* voice)
<a name="l01546"></a>01546 {
<a name="l01547"></a>01547   fluid_profile(FLUID_PROF_VOICE_NOTE, voice-&gt;ref);
<a name="l01548"></a>01548 
<a name="l01549"></a>01549   <span class="keywordflow">if</span> (voice-&gt;channel &amp;&amp; fluid_channel_sustained(voice-&gt;channel)) {
<a name="l01550"></a>01550     voice-&gt;status = FLUID_VOICE_SUSTAINED;
<a name="l01551"></a>01551   } <span class="keywordflow">else</span> {
<a name="l01552"></a>01552     <span class="keywordflow">if</span> (voice-&gt;volenv_section == FLUID_VOICE_ENVATTACK) {
<a name="l01553"></a>01553       <span class="comment">/* A voice is turned off during the attack section of the volume</span>
<a name="l01554"></a>01554 <span class="comment">       * envelope.  The attack section ramps up linearly with</span>
<a name="l01555"></a>01555 <span class="comment">       * amplitude. The other sections use logarithmic scaling. Calculate new</span>
<a name="l01556"></a>01556 <span class="comment">       * volenv_val to achieve equievalent amplitude during the release phase</span>
<a name="l01557"></a>01557 <span class="comment">       * for seamless volume transition.</span>
<a name="l01558"></a>01558 <span class="comment">       */</span>
<a name="l01559"></a>01559       <span class="keywordflow">if</span> (voice-&gt;volenv_val &gt; 0){
<a name="l01560"></a>01560         fluid_real_t lfo = voice-&gt;modlfo_val * -voice-&gt;modlfo_to_vol;
<a name="l01561"></a>01561         fluid_real_t amp = voice-&gt;volenv_val * pow (10.0, lfo / -200);
<a name="l01562"></a>01562         fluid_real_t env_value = - ((-200 * log (amp) / log (10.0) - lfo) / 960.0 - 1);
<a name="l01563"></a>01563         fluid_clip (env_value, 0.0, 1.0);
<a name="l01564"></a>01564         voice-&gt;volenv_val = env_value;
<a name="l01565"></a>01565       }
<a name="l01566"></a>01566     }
<a name="l01567"></a>01567     voice-&gt;volenv_section = FLUID_VOICE_ENVRELEASE;
<a name="l01568"></a>01568     voice-&gt;volenv_count = 0;
<a name="l01569"></a>01569     voice-&gt;modenv_section = FLUID_VOICE_ENVRELEASE;
<a name="l01570"></a>01570     voice-&gt;modenv_count = 0;
<a name="l01571"></a>01571   }
<a name="l01572"></a>01572 
<a name="l01573"></a>01573   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01574"></a>01574 }
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 <span class="comment">/*</span>
<a name="l01577"></a>01577 <span class="comment"> * fluid_voice_kill_excl</span>
<a name="l01578"></a>01578 <span class="comment"> *</span>
<a name="l01579"></a>01579 <span class="comment"> * Percussion sounds can be mutually exclusive: for example, a 'closed</span>
<a name="l01580"></a>01580 <span class="comment"> * hihat' sound will terminate an 'open hihat' sound ringing at the</span>
<a name="l01581"></a>01581 <span class="comment"> * same time. This behaviour is modeled using 'exclusive classes',</span>
<a name="l01582"></a>01582 <span class="comment"> * turning on a voice with an exclusive class other than 0 will kill</span>
<a name="l01583"></a>01583 <span class="comment"> * all other voices having that exclusive class within the same preset</span>
<a name="l01584"></a>01584 <span class="comment"> * or channel.  fluid_voice_kill_excl gets called, when 'voice' is to</span>
<a name="l01585"></a>01585 <span class="comment"> * be killed for that reason.</span>
<a name="l01586"></a>01586 <span class="comment"> */</span>
<a name="l01587"></a>01587 <span class="keywordtype">int</span>
<a name="l01588"></a>01588 fluid_voice_kill_excl(fluid_voice_t* voice){
<a name="l01589"></a>01589 
<a name="l01590"></a>01590   <span class="keywordflow">if</span> (!_PLAYING(voice)) {
<a name="l01591"></a>01591     <span class="keywordflow">return</span> FLUID_OK;
<a name="l01592"></a>01592   }
<a name="l01593"></a>01593 
<a name="l01594"></a>01594   <span class="comment">/* Turn off the exclusive class information for this voice,</span>
<a name="l01595"></a>01595 <span class="comment">     so that it doesn't get killed twice</span>
<a name="l01596"></a>01596 <span class="comment">  */</span>
<a name="l01597"></a>01597   fluid_voice_gen_set(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4900ee448f717ec582dac28ce51d08914" title="Exclusive class number.">GEN_EXCLUSIVECLASS</a>, 0);
<a name="l01598"></a>01598 
<a name="l01599"></a>01599   <span class="comment">/* If the voice is not yet in release state, put it into release state */</span>
<a name="l01600"></a>01600   <span class="keywordflow">if</span> (voice-&gt;volenv_section != FLUID_VOICE_ENVRELEASE){
<a name="l01601"></a>01601     voice-&gt;volenv_section = FLUID_VOICE_ENVRELEASE;
<a name="l01602"></a>01602     voice-&gt;volenv_count = 0;
<a name="l01603"></a>01603     voice-&gt;modenv_section = FLUID_VOICE_ENVRELEASE;
<a name="l01604"></a>01604     voice-&gt;modenv_count = 0;
<a name="l01605"></a>01605   }
<a name="l01606"></a>01606 
<a name="l01607"></a>01607   <span class="comment">/* Speed up the volume envelope */</span>
<a name="l01608"></a>01608   <span class="comment">/* The value was found through listening tests with hi-hat samples. */</span>
<a name="l01609"></a>01609   fluid_voice_gen_set(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4ca3b587527e748ea7aabb2e3a28e70e7" title="Volume envelope release.">GEN_VOLENVRELEASE</a>, -200);
<a name="l01610"></a>01610   fluid_voice_update_param(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4ca3b587527e748ea7aabb2e3a28e70e7" title="Volume envelope release.">GEN_VOLENVRELEASE</a>);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612   <span class="comment">/* Speed up the modulation envelope */</span>
<a name="l01613"></a>01613   fluid_voice_gen_set(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4d7594c8e4d03e62f7bd5a8770fc6e3d2" title="Modulation envelope release.">GEN_MODENVRELEASE</a>, -200);
<a name="l01614"></a>01614   fluid_voice_update_param(voice, <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b4d7594c8e4d03e62f7bd5a8770fc6e3d2" title="Modulation envelope release.">GEN_MODENVRELEASE</a>);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01617"></a>01617 }
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 <span class="comment">/*</span>
<a name="l01620"></a>01620 <span class="comment"> * fluid_voice_off</span>
<a name="l01621"></a>01621 <span class="comment"> *</span>
<a name="l01622"></a>01622 <span class="comment"> * Purpose:</span>
<a name="l01623"></a>01623 <span class="comment"> * Turns off a voice, meaning that it is not processed</span>
<a name="l01624"></a>01624 <span class="comment"> * anymore by the DSP loop.</span>
<a name="l01625"></a>01625 <span class="comment"> */</span>
<a name="l01626"></a>01626 <span class="keywordtype">int</span>
<a name="l01627"></a>01627 fluid_voice_off(fluid_voice_t* voice)
<a name="l01628"></a>01628 {
<a name="l01629"></a>01629   fluid_profile(FLUID_PROF_VOICE_RELEASE, voice-&gt;ref);
<a name="l01630"></a>01630 
<a name="l01631"></a>01631   voice-&gt;chan = NO_CHANNEL;
<a name="l01632"></a>01632   voice-&gt;volenv_section = FLUID_VOICE_ENVFINISHED;
<a name="l01633"></a>01633   voice-&gt;volenv_count = 0;
<a name="l01634"></a>01634   voice-&gt;modenv_section = FLUID_VOICE_ENVFINISHED;
<a name="l01635"></a>01635   voice-&gt;modenv_count = 0;
<a name="l01636"></a>01636   voice-&gt;status = FLUID_VOICE_OFF;
<a name="l01637"></a>01637 
<a name="l01638"></a>01638   <span class="comment">/* Decrement the reference count of the sample. */</span>
<a name="l01639"></a>01639   <span class="keywordflow">if</span> (voice-&gt;sample) {
<a name="l01640"></a>01640     fluid_sample_decr_ref(voice-&gt;sample);
<a name="l01641"></a>01641     voice-&gt;sample = NULL;
<a name="l01642"></a>01642   }
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01645"></a>01645 }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647 <span class="comment">/*</span>
<a name="l01648"></a>01648 <span class="comment"> * fluid_voice_add_mod</span>
<a name="l01649"></a>01649 <span class="comment"> *</span>
<a name="l01650"></a>01650 <span class="comment"> * Adds a modulator to the voice.  "mode" indicates, what to do, if</span>
<a name="l01651"></a>01651 <span class="comment"> * an identical modulator exists already.</span>
<a name="l01652"></a>01652 <span class="comment"> *</span>
<a name="l01653"></a>01653 <span class="comment"> * mode == FLUID_VOICE_ADD: Identical modulators on preset level are added</span>
<a name="l01654"></a>01654 <span class="comment"> * mode == FLUID_VOICE_OVERWRITE: Identical modulators on instrument level are overwritten</span>
<a name="l01655"></a>01655 <span class="comment"> * mode == FLUID_VOICE_DEFAULT: This is a default modulator, there can be no identical modulator.</span>
<a name="l01656"></a>01656 <span class="comment"> *                             Don't check.</span>
<a name="l01657"></a>01657 <span class="comment"> */</span>
<a name="l01658"></a>01658 <span class="keywordtype">void</span>
<a name="l01659"></a>01659 fluid_voice_add_mod(fluid_voice_t* voice, <a class="code" href="struct__fluid__mod__t.html">fluid_mod_t</a>* mod, <span class="keywordtype">int</span> mode)
<a name="l01660"></a>01660 {
<a name="l01661"></a>01661   <span class="keywordtype">int</span> i;
<a name="l01662"></a>01662 
<a name="l01663"></a>01663   <span class="comment">/*</span>
<a name="l01664"></a>01664 <span class="comment">   * Some soundfonts come with a huge number of non-standard</span>
<a name="l01665"></a>01665 <span class="comment">   * controllers, because they have been designed for one particular</span>
<a name="l01666"></a>01666 <span class="comment">   * sound card.  Discard them, maybe print a warning.</span>
<a name="l01667"></a>01667 <span class="comment">   */</span>
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="keywordflow">if</span> (((mod-&gt;<a class="code" href="struct__fluid__mod__t.html#db71cc4a4b81c915f05c1b8d069e3056">flags1</a> &amp; FLUID_MOD_CC) == 0)
<a name="l01670"></a>01670       &amp;&amp; ((mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 0)          <span class="comment">/* SF2.01 section 8.2.1: Constant value */</span>
<a name="l01671"></a>01671           &amp;&amp; (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 2)       <span class="comment">/* Note-on velocity */</span>
<a name="l01672"></a>01672           &amp;&amp; (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 3)       <span class="comment">/* Note-on key number */</span>
<a name="l01673"></a>01673           &amp;&amp; (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 10)      <span class="comment">/* Poly pressure */</span>
<a name="l01674"></a>01674           &amp;&amp; (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 13)      <span class="comment">/* Channel pressure */</span>
<a name="l01675"></a>01675           &amp;&amp; (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 14)      <span class="comment">/* Pitch wheel */</span>
<a name="l01676"></a>01676           &amp;&amp; (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> != 16))) {  <span class="comment">/* Pitch wheel sensitivity */</span>
<a name="l01677"></a>01677     FLUID_LOG(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e394460be1ec74fce15e1ff683606df0f" title="Warning.">FLUID_WARN</a>, <span class="stringliteral">"Ignoring invalid controller, using non-CC source %i."</span>, mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a>);
<a name="l01678"></a>01678     <span class="keywordflow">return</span>;
<a name="l01679"></a>01679   }
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   <span class="keywordflow">if</span> (mode == FLUID_VOICE_ADD) {
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     <span class="comment">/* if identical modulator exists, add them */</span>
<a name="l01684"></a>01684     <span class="keywordflow">for</span> (i = 0; i &lt; voice-&gt;mod_count; i++) {
<a name="l01685"></a>01685       <span class="keywordflow">if</span> (fluid_mod_test_identity(&amp;voice-&gt;mod[i], mod)) {
<a name="l01686"></a>01686         <span class="comment">//              printf("Adding modulator...\n");</span>
<a name="l01687"></a>01687         voice-&gt;mod[i].amount += mod-&gt;<a class="code" href="struct__fluid__mod__t.html#89680a436126f578594c5981d6c4f2ad">amount</a>;
<a name="l01688"></a>01688         <span class="keywordflow">return</span>;
<a name="l01689"></a>01689       }
<a name="l01690"></a>01690     }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == FLUID_VOICE_OVERWRITE) {
<a name="l01693"></a>01693 
<a name="l01694"></a>01694     <span class="comment">/* if identical modulator exists, replace it (only the amount has to be changed) */</span>
<a name="l01695"></a>01695     <span class="keywordflow">for</span> (i = 0; i &lt; voice-&gt;mod_count; i++) {
<a name="l01696"></a>01696       <span class="keywordflow">if</span> (fluid_mod_test_identity(&amp;voice-&gt;mod[i], mod)) {
<a name="l01697"></a>01697         <span class="comment">//              printf("Replacing modulator...amount is %f\n",mod-&gt;amount);</span>
<a name="l01698"></a>01698         voice-&gt;mod[i].amount = mod-&gt;<a class="code" href="struct__fluid__mod__t.html#89680a436126f578594c5981d6c4f2ad">amount</a>;
<a name="l01699"></a>01699         <span class="keywordflow">return</span>;
<a name="l01700"></a>01700       }
<a name="l01701"></a>01701     }
<a name="l01702"></a>01702   }
<a name="l01703"></a>01703 
<a name="l01704"></a>01704   <span class="comment">/* Add a new modulator (No existing modulator to add / overwrite).</span>
<a name="l01705"></a>01705 <span class="comment">     Also, default modulators (FLUID_VOICE_DEFAULT) are added without</span>
<a name="l01706"></a>01706 <span class="comment">     checking, if the same modulator already exists. */</span>
<a name="l01707"></a>01707   <span class="keywordflow">if</span> (voice-&gt;mod_count &lt; FLUID_NUM_MOD) {
<a name="l01708"></a>01708     fluid_mod_clone(&amp;voice-&gt;mod[voice-&gt;mod_count++], mod);
<a name="l01709"></a>01709   }
<a name="l01710"></a>01710 }
<a name="l01711"></a>01711 
<a name="l01712"></a>01712 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_voice_get_id(fluid_voice_t* voice)
<a name="l01713"></a>01713 {
<a name="l01714"></a>01714   <span class="keywordflow">return</span> voice-&gt;id;
<a name="l01715"></a>01715 }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717 <span class="keywordtype">int</span> fluid_voice_is_playing(fluid_voice_t* voice)
<a name="l01718"></a>01718 {
<a name="l01719"></a>01719   <span class="keywordflow">return</span> _PLAYING(voice);
<a name="l01720"></a>01720 }
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 <span class="comment">/*</span>
<a name="l01723"></a>01723 <span class="comment"> * fluid_voice_get_lower_boundary_for_attenuation</span>
<a name="l01724"></a>01724 <span class="comment"> *</span>
<a name="l01725"></a>01725 <span class="comment"> * Purpose:</span>
<a name="l01726"></a>01726 <span class="comment"> *</span>
<a name="l01727"></a>01727 <span class="comment"> * A lower boundary for the attenuation (as in 'the minimum</span>
<a name="l01728"></a>01728 <span class="comment"> * attenuation of this voice, with volume pedals, modulators</span>
<a name="l01729"></a>01729 <span class="comment"> * etc. resulting in minimum attenuation, cannot fall below x cB) is</span>
<a name="l01730"></a>01730 <span class="comment"> * calculated.  This has to be called during fluid_voice_init, after</span>
<a name="l01731"></a>01731 <span class="comment"> * all modulators have been run on the voice once.  Also,</span>
<a name="l01732"></a>01732 <span class="comment"> * voice-&gt;attenuation has to be initialized.</span>
<a name="l01733"></a>01733 <span class="comment"> */</span>
<a name="l01734"></a>01734 fluid_real_t fluid_voice_get_lower_boundary_for_attenuation(fluid_voice_t* voice)
<a name="l01735"></a>01735 {
<a name="l01736"></a>01736   <span class="keywordtype">int</span> i;
<a name="l01737"></a>01737   <a class="code" href="struct__fluid__mod__t.html">fluid_mod_t</a>* mod;
<a name="l01738"></a>01738   fluid_real_t possible_att_reduction_cB=0;
<a name="l01739"></a>01739   fluid_real_t lower_bound;
<a name="l01740"></a>01740 
<a name="l01741"></a>01741   <span class="keywordflow">for</span> (i = 0; i &lt; voice-&gt;mod_count; i++) {
<a name="l01742"></a>01742     mod = &amp;voice-&gt;mod[i];
<a name="l01743"></a>01743 
<a name="l01744"></a>01744     <span class="comment">/* Modulator has attenuation as target and can change over time? */</span>
<a name="l01745"></a>01745     <span class="keywordflow">if</span> ((mod-&gt;<a class="code" href="struct__fluid__mod__t.html#1c7d15ae9ad239b578701878b0ffbb08">dest</a> == <a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b42db65ad593aeff4e814f9a7b7324c0df" title="Initial volume attenuation.">GEN_ATTENUATION</a>)
<a name="l01746"></a>01746         &amp;&amp; ((mod-&gt;<a class="code" href="struct__fluid__mod__t.html#db71cc4a4b81c915f05c1b8d069e3056">flags1</a> &amp; FLUID_MOD_CC) || (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#38e059fb4214ab59b5f0895d100dfffa">flags2</a> &amp; FLUID_MOD_CC))) {
<a name="l01747"></a>01747 
<a name="l01748"></a>01748       fluid_real_t current_val = fluid_mod_get_value(mod, voice-&gt;channel, voice);
<a name="l01749"></a>01749       fluid_real_t v = fabs(mod-&gt;<a class="code" href="struct__fluid__mod__t.html#89680a436126f578594c5981d6c4f2ad">amount</a>);
<a name="l01750"></a>01750 
<a name="l01751"></a>01751       <span class="keywordflow">if</span> ((mod-&gt;<a class="code" href="struct__fluid__mod__t.html#199e73690c3e5fdb0e073d05f8237196">src1</a> == FLUID_MOD_PITCHWHEEL)
<a name="l01752"></a>01752           || (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#db71cc4a4b81c915f05c1b8d069e3056">flags1</a> &amp; FLUID_MOD_BIPOLAR)
<a name="l01753"></a>01753           || (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#38e059fb4214ab59b5f0895d100dfffa">flags2</a> &amp; FLUID_MOD_BIPOLAR)
<a name="l01754"></a>01754           || (mod-&gt;<a class="code" href="struct__fluid__mod__t.html#89680a436126f578594c5981d6c4f2ad">amount</a> &lt; 0)) {
<a name="l01755"></a>01755         <span class="comment">/* Can this modulator produce a negative contribution? */</span>
<a name="l01756"></a>01756         v *= -1.0;
<a name="l01757"></a>01757       } <span class="keywordflow">else</span> {
<a name="l01758"></a>01758         <span class="comment">/* No negative value possible. But still, the minimum contribution is 0. */</span>
<a name="l01759"></a>01759         v = 0;
<a name="l01760"></a>01760       }
<a name="l01761"></a>01761 
<a name="l01762"></a>01762       <span class="comment">/* For example:</span>
<a name="l01763"></a>01763 <span class="comment">       * - current_val=100</span>
<a name="l01764"></a>01764 <span class="comment">       * - min_val=-4000</span>
<a name="l01765"></a>01765 <span class="comment">       * - possible_att_reduction_cB += 4100</span>
<a name="l01766"></a>01766 <span class="comment">       */</span>
<a name="l01767"></a>01767       <span class="keywordflow">if</span> (current_val &gt; v){
<a name="l01768"></a>01768         possible_att_reduction_cB += (current_val - v);
<a name="l01769"></a>01769       }
<a name="l01770"></a>01770     }
<a name="l01771"></a>01771   }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773   lower_bound = voice-&gt;attenuation-possible_att_reduction_cB;
<a name="l01774"></a>01774 
<a name="l01775"></a>01775   <span class="comment">/* SF2.01 specs do not allow negative attenuation */</span>
<a name="l01776"></a>01776   <span class="keywordflow">if</span> (lower_bound &lt; 0) {
<a name="l01777"></a>01777     lower_bound = 0;
<a name="l01778"></a>01778   }
<a name="l01779"></a>01779   <span class="keywordflow">return</span> lower_bound;
<a name="l01780"></a>01780 }
<a name="l01781"></a>01781 
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="comment">/* Purpose:</span>
<a name="l01784"></a>01784 <span class="comment"> *</span>
<a name="l01785"></a>01785 <span class="comment"> * Make sure, that sample start / end point and loop points are in</span>
<a name="l01786"></a>01786 <span class="comment"> * proper order. When starting up, calculate the initial phase.</span>
<a name="l01787"></a>01787 <span class="comment"> */</span>
<a name="l01788"></a>01788 <span class="keywordtype">void</span> fluid_voice_check_sample_sanity(fluid_voice_t* voice)
<a name="l01789"></a>01789 {
<a name="l01790"></a>01790     <span class="keywordtype">int</span> min_index_nonloop=(int) voice-&gt;sample-&gt;start;
<a name="l01791"></a>01791     <span class="keywordtype">int</span> max_index_nonloop=(<span class="keywordtype">int</span>) voice-&gt;sample-&gt;end;
<a name="l01792"></a>01792 
<a name="l01793"></a>01793     <span class="comment">/* make sure we have enough samples surrounding the loop */</span>
<a name="l01794"></a>01794     <span class="keywordtype">int</span> min_index_loop=(int) voice-&gt;sample-&gt;start + FLUID_MIN_LOOP_PAD;
<a name="l01795"></a>01795     <span class="keywordtype">int</span> max_index_loop=(<span class="keywordtype">int</span>) voice-&gt;sample-&gt;end - FLUID_MIN_LOOP_PAD + 1;       <span class="comment">/* 'end' is last valid sample, loopend can be + 1 */</span>
<a name="l01796"></a>01796     fluid_check_fpe(<span class="stringliteral">"voice_check_sample_sanity start"</span>);
<a name="l01797"></a>01797 
<a name="l01798"></a>01798     <span class="keywordflow">if</span> (!voice-&gt;check_sample_sanity_flag){
<a name="l01799"></a>01799         <span class="keywordflow">return</span>;
<a name="l01800"></a>01800     }
<a name="l01801"></a>01801 
<a name="l01802"></a>01802 <span class="preprocessor">#if 0</span>
<a name="l01803"></a>01803 <span class="preprocessor"></span>    printf(<span class="stringliteral">"Sample from %i to %i\n"</span>,voice-&gt;sample-&gt;start, voice-&gt;sample-&gt;end);
<a name="l01804"></a>01804     printf(<span class="stringliteral">"Sample loop from %i %i\n"</span>,voice-&gt;sample-&gt;loopstart, voice-&gt;sample-&gt;loopend);
<a name="l01805"></a>01805     printf(<span class="stringliteral">"Playback from %i to %i\n"</span>, voice-&gt;start, voice-&gt;end);
<a name="l01806"></a>01806     printf(<span class="stringliteral">"Playback loop from %i to %i\n"</span>,voice-&gt;loopstart, voice-&gt;loopend);
<a name="l01807"></a>01807 <span class="preprocessor">#endif</span>
<a name="l01808"></a>01808 <span class="preprocessor"></span>
<a name="l01809"></a>01809     <span class="comment">/* Keep the start point within the sample data */</span>
<a name="l01810"></a>01810     <span class="keywordflow">if</span> (voice-&gt;start &lt; min_index_nonloop){
<a name="l01811"></a>01811         voice-&gt;start = min_index_nonloop;
<a name="l01812"></a>01812     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (voice-&gt;start &gt; max_index_nonloop){
<a name="l01813"></a>01813         voice-&gt;start = max_index_nonloop;
<a name="l01814"></a>01814     }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816     <span class="comment">/* Keep the end point within the sample data */</span>
<a name="l01817"></a>01817     <span class="keywordflow">if</span> (voice-&gt;end &lt; min_index_nonloop){
<a name="l01818"></a>01818       voice-&gt;end = min_index_nonloop;
<a name="l01819"></a>01819     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (voice-&gt;end &gt; max_index_nonloop){
<a name="l01820"></a>01820       voice-&gt;end = max_index_nonloop;
<a name="l01821"></a>01821     }
<a name="l01822"></a>01822 
<a name="l01823"></a>01823     <span class="comment">/* Keep start and end point in the right order */</span>
<a name="l01824"></a>01824     <span class="keywordflow">if</span> (voice-&gt;start &gt; voice-&gt;end){
<a name="l01825"></a>01825         <span class="keywordtype">int</span> temp = voice-&gt;start;
<a name="l01826"></a>01826         voice-&gt;start = voice-&gt;end;
<a name="l01827"></a>01827         voice-&gt;end = temp;
<a name="l01828"></a>01828         <span class="comment">/*FLUID_LOG(FLUID_DBG, "Loop / sample sanity check: Changing order of start / end points!"); */</span>
<a name="l01829"></a>01829     }
<a name="l01830"></a>01830 
<a name="l01831"></a>01831     <span class="comment">/* Zero length? */</span>
<a name="l01832"></a>01832     <span class="keywordflow">if</span> (voice-&gt;start == voice-&gt;end){
<a name="l01833"></a>01833         fluid_voice_off(voice);
<a name="l01834"></a>01834         <span class="keywordflow">return</span>;
<a name="l01835"></a>01835     }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837     <span class="keywordflow">if</span> ((_SAMPLEMODE(voice) == FLUID_LOOP_UNTIL_RELEASE)
<a name="l01838"></a>01838         || (_SAMPLEMODE(voice) == FLUID_LOOP_DURING_RELEASE)) {
<a name="l01839"></a>01839         <span class="comment">/* Keep the loop start point within the sample data */</span>
<a name="l01840"></a>01840         <span class="keywordflow">if</span> (voice-&gt;loopstart &lt; min_index_loop){
<a name="l01841"></a>01841             voice-&gt;loopstart = min_index_loop;
<a name="l01842"></a>01842       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (voice-&gt;loopstart &gt; max_index_loop){
<a name="l01843"></a>01843         voice-&gt;loopstart = max_index_loop;
<a name="l01844"></a>01844       }
<a name="l01845"></a>01845 
<a name="l01846"></a>01846       <span class="comment">/* Keep the loop end point within the sample data */</span>
<a name="l01847"></a>01847       <span class="keywordflow">if</span> (voice-&gt;loopend &lt; min_index_loop){
<a name="l01848"></a>01848         voice-&gt;loopend = min_index_loop;
<a name="l01849"></a>01849       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (voice-&gt;loopend &gt; max_index_loop){
<a name="l01850"></a>01850         voice-&gt;loopend = max_index_loop;
<a name="l01851"></a>01851       }
<a name="l01852"></a>01852 
<a name="l01853"></a>01853       <span class="comment">/* Keep loop start and end point in the right order */</span>
<a name="l01854"></a>01854       <span class="keywordflow">if</span> (voice-&gt;loopstart &gt; voice-&gt;loopend){
<a name="l01855"></a>01855         <span class="keywordtype">int</span> temp = voice-&gt;loopstart;
<a name="l01856"></a>01856         voice-&gt;loopstart = voice-&gt;loopend;
<a name="l01857"></a>01857         voice-&gt;loopend = temp;
<a name="l01858"></a>01858         <span class="comment">/*FLUID_LOG(FLUID_DBG, "Loop / sample sanity check: Changing order of loop points!"); */</span>
<a name="l01859"></a>01859       }
<a name="l01860"></a>01860 
<a name="l01861"></a>01861       <span class="comment">/* Loop too short? Then don't loop. */</span>
<a name="l01862"></a>01862       <span class="keywordflow">if</span> (voice-&gt;loopend &lt; voice-&gt;loopstart + FLUID_MIN_LOOP_SIZE){
<a name="l01863"></a>01863           voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45b654b7cb64659b6a48d39bf0b11bc06" title="Sample mode flags.">GEN_SAMPLEMODE</a>].val = FLUID_UNLOOPED;
<a name="l01864"></a>01864       }
<a name="l01865"></a>01865 
<a name="l01866"></a>01866       <span class="comment">/* The loop points may have changed. Obtain a new estimate for the loop volume. */</span>
<a name="l01867"></a>01867       <span class="comment">/* Is the voice loop within the sample loop? */</span>
<a name="l01868"></a>01868       <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)voice-&gt;loopstart &gt;= (<span class="keywordtype">int</span>)voice-&gt;sample-&gt;loopstart
<a name="l01869"></a>01869           &amp;&amp; (<span class="keywordtype">int</span>)voice-&gt;loopend &lt;= (<span class="keywordtype">int</span>)voice-&gt;sample-&gt;loopend){
<a name="l01870"></a>01870         <span class="comment">/* Is there a valid peak amplitude available for the loop? */</span>
<a name="l01871"></a>01871         <span class="keywordflow">if</span> (voice-&gt;sample-&gt;amplitude_that_reaches_noise_floor_is_valid){
<a name="l01872"></a>01872           voice-&gt;amplitude_that_reaches_noise_floor_loop=voice-&gt;sample-&gt;amplitude_that_reaches_noise_floor / voice-&gt;synth_gain;
<a name="l01873"></a>01873         } <span class="keywordflow">else</span> {
<a name="l01874"></a>01874           <span class="comment">/* Worst case */</span>
<a name="l01875"></a>01875           voice-&gt;amplitude_that_reaches_noise_floor_loop=voice-&gt;amplitude_that_reaches_noise_floor_nonloop;
<a name="l01876"></a>01876         };
<a name="l01877"></a>01877       };
<a name="l01878"></a>01878 
<a name="l01879"></a>01879     } <span class="comment">/* if sample mode is looped */</span>
<a name="l01880"></a>01880 
<a name="l01881"></a>01881     <span class="comment">/* Run startup specific code (only once, when the voice is started) */</span>
<a name="l01882"></a>01882     <span class="keywordflow">if</span> (voice-&gt;check_sample_sanity_flag &amp; FLUID_SAMPLESANITY_STARTUP){
<a name="l01883"></a>01883       <span class="keywordflow">if</span> (max_index_loop - min_index_loop &lt; FLUID_MIN_LOOP_SIZE){
<a name="l01884"></a>01884         <span class="keywordflow">if</span> ((_SAMPLEMODE(voice) == FLUID_LOOP_UNTIL_RELEASE)
<a name="l01885"></a>01885             || (_SAMPLEMODE(voice) == FLUID_LOOP_DURING_RELEASE)){
<a name="l01886"></a>01886           voice-&gt;gen[<a class="code" href="gen_8h.html#d17a24ae3b25f3b8cc5762f818eef9b45b654b7cb64659b6a48d39bf0b11bc06" title="Sample mode flags.">GEN_SAMPLEMODE</a>].val = FLUID_UNLOOPED;
<a name="l01887"></a>01887         }
<a name="l01888"></a>01888       }
<a name="l01889"></a>01889 
<a name="l01890"></a>01890       <span class="comment">/* Set the initial phase of the voice (using the result from the</span>
<a name="l01891"></a>01891 <span class="comment">         start offset modulators). */</span>
<a name="l01892"></a>01892       fluid_phase_set_int(voice-&gt;phase, voice-&gt;start);
<a name="l01893"></a>01893     } <span class="comment">/* if startup */</span>
<a name="l01894"></a>01894 
<a name="l01895"></a>01895     <span class="comment">/* Is this voice run in loop mode, or does it run straight to the</span>
<a name="l01896"></a>01896 <span class="comment">       end of the waveform data? */</span>
<a name="l01897"></a>01897     <span class="keywordflow">if</span> (((_SAMPLEMODE(voice) == FLUID_LOOP_UNTIL_RELEASE) &amp;&amp; (voice-&gt;volenv_section &lt; FLUID_VOICE_ENVRELEASE))
<a name="l01898"></a>01898         || (_SAMPLEMODE(voice) == FLUID_LOOP_DURING_RELEASE)) {
<a name="l01899"></a>01899       <span class="comment">/* Yes, it will loop as soon as it reaches the loop point.  In</span>
<a name="l01900"></a>01900 <span class="comment">       * this case we must prevent, that the playback pointer (phase)</span>
<a name="l01901"></a>01901 <span class="comment">       * happens to end up beyond the 2nd loop point, because the</span>
<a name="l01902"></a>01902 <span class="comment">       * point has moved.  The DSP algorithm is unable to cope with</span>
<a name="l01903"></a>01903 <span class="comment">       * that situation.  So if the phase is beyond the 2nd loop</span>
<a name="l01904"></a>01904 <span class="comment">       * point, set it to the start of the loop. No way to avoid some</span>
<a name="l01905"></a>01905 <span class="comment">       * noise here.  Note: If the sample pointer ends up -before the</span>
<a name="l01906"></a>01906 <span class="comment">       * first loop point- instead, then the DSP loop will just play</span>
<a name="l01907"></a>01907 <span class="comment">       * the sample, enter the loop and proceed as expected =&gt; no</span>
<a name="l01908"></a>01908 <span class="comment">       * actions required.</span>
<a name="l01909"></a>01909 <span class="comment">       */</span>
<a name="l01910"></a>01910       <span class="keywordtype">int</span> index_in_sample = fluid_phase_index(voice-&gt;phase);
<a name="l01911"></a>01911       <span class="keywordflow">if</span> (index_in_sample &gt;= voice-&gt;loopend){
<a name="l01912"></a>01912         <span class="comment">/* FLUID_LOG(FLUID_DBG, "Loop / sample sanity check: Phase after 2nd loop point!"); */</span>
<a name="l01913"></a>01913         fluid_phase_set_int(voice-&gt;phase, voice-&gt;loopstart);
<a name="l01914"></a>01914       }
<a name="l01915"></a>01915     }
<a name="l01916"></a>01916 <span class="comment">/*    FLUID_LOG(FLUID_DBG, "Loop / sample sanity check: Sample from %i to %i, loop from %i to %i", voice-&gt;start, voice-&gt;end, voice-&gt;loopstart, voice-&gt;loopend); */</span>
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     <span class="comment">/* Sample sanity has been assured. Don't check again, until some</span>
<a name="l01919"></a>01919 <span class="comment">       sample parameter is changed by modulation. */</span>
<a name="l01920"></a>01920     voice-&gt;check_sample_sanity_flag=0;
<a name="l01921"></a>01921 <span class="preprocessor">#if 0</span>
<a name="l01922"></a>01922 <span class="preprocessor"></span>    printf(<span class="stringliteral">"Sane? playback loop from %i to %i\n"</span>, voice-&gt;loopstart, voice-&gt;loopend);
<a name="l01923"></a>01923 <span class="preprocessor">#endif</span>
<a name="l01924"></a>01924 <span class="preprocessor"></span>    fluid_check_fpe(<span class="stringliteral">"voice_check_sample_sanity"</span>);
<a name="l01925"></a>01925 }
<a name="l01926"></a>01926 
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 <span class="keywordtype">int</span> fluid_voice_set_param(fluid_voice_t* voice, <span class="keywordtype">int</span> gen, fluid_real_t nrpn_value, <span class="keywordtype">int</span> abs)
<a name="l01929"></a>01929 {
<a name="l01930"></a>01930   voice-&gt;gen[gen].nrpn = nrpn_value;
<a name="l01931"></a>01931   voice-&gt;gen[gen].flags = (abs)? <a class="code" href="gen_8h.html#96f1389ca9e52d85cdf1160a038b4bb5d9b34811c11a1b5078befb70b14c2285" title="DOCME.">GEN_ABS_NRPN</a> : <a class="code" href="gen_8h.html#96f1389ca9e52d85cdf1160a038b4bb5addb45ff06d85814a429100ba9099c1f" title="Generator value is set.">GEN_SET</a>;
<a name="l01932"></a>01932   fluid_voice_update_param(voice, gen);
<a name="l01933"></a>01933   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01934"></a>01934 }
<a name="l01935"></a>01935 
<a name="l01936"></a>01936 <span class="keywordtype">int</span> fluid_voice_set_gain(fluid_voice_t* voice, fluid_real_t gain)
<a name="l01937"></a>01937 {
<a name="l01938"></a>01938   <span class="comment">/* avoid division by zero*/</span>
<a name="l01939"></a>01939   <span class="keywordflow">if</span> (gain &lt; 0.0000001){
<a name="l01940"></a>01940     gain = 0.0000001;
<a name="l01941"></a>01941   }
<a name="l01942"></a>01942 
<a name="l01943"></a>01943   voice-&gt;synth_gain = gain;
<a name="l01944"></a>01944   voice-&gt;amp_left = fluid_pan(voice-&gt;pan, 1) * gain / 32768.0f;
<a name="l01945"></a>01945   voice-&gt;amp_right = fluid_pan(voice-&gt;pan, 0) * gain / 32768.0f;
<a name="l01946"></a>01946   voice-&gt;amp_reverb = voice-&gt;reverb_send * gain / 32768.0f;
<a name="l01947"></a>01947   voice-&gt;amp_chorus = voice-&gt;chorus_send * gain / 32768.0f;
<a name="l01948"></a>01948 
<a name="l01949"></a>01949   <span class="keywordflow">return</span> FLUID_OK;
<a name="l01950"></a>01950 }
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 <span class="comment">/* - Scan the loop</span>
<a name="l01953"></a>01953 <span class="comment"> * - determine the peak level</span>
<a name="l01954"></a>01954 <span class="comment"> * - Calculate, what factor will make the loop inaudible</span>
<a name="l01955"></a>01955 <span class="comment"> * - Store in sample</span>
<a name="l01956"></a>01956 <span class="comment"> */</span>
<a name="l01957"></a>01957 <span class="keywordtype">int</span> fluid_voice_optimize_sample(<a class="code" href="struct__fluid__sample__t.html">fluid_sample_t</a>* s)
<a name="l01958"></a>01958 {
<a name="l01959"></a>01959   <span class="keywordtype">signed</span> <span class="keywordtype">short</span> peak_max = 0;
<a name="l01960"></a>01960   <span class="keywordtype">signed</span> <span class="keywordtype">short</span> peak_min = 0;
<a name="l01961"></a>01961   <span class="keywordtype">signed</span> <span class="keywordtype">short</span> peak;
<a name="l01962"></a>01962   fluid_real_t normalized_amplitude_during_loop;
<a name="l01963"></a>01963   <span class="keywordtype">double</span> result;
<a name="l01964"></a>01964   <span class="keywordtype">int</span> i;
<a name="l01965"></a>01965 
<a name="l01966"></a>01966   <span class="comment">/* ignore ROM and other(?) invalid samples */</span>
<a name="l01967"></a>01967   <span class="keywordflow">if</span> (!s-&gt;<a class="code" href="struct__fluid__sample__t.html#d95a25c77565b132e686cc3f14687221">valid</a>) <span class="keywordflow">return</span> (FLUID_OK);
<a name="l01968"></a>01968 
<a name="l01969"></a>01969   <span class="keywordflow">if</span> (!s-&gt;<a class="code" href="struct__fluid__sample__t.html#c054e203acd07ad158256e343f1fd0a5" title="The amplitude, that will lower the level of the sample&amp;#39;s loop to the noise floor...">amplitude_that_reaches_noise_floor_is_valid</a>){ <span class="comment">/* Only once */</span>
<a name="l01970"></a>01970     <span class="comment">/* Scan the loop */</span>
<a name="l01971"></a>01971     <span class="keywordflow">for</span> (i = (<span class="keywordtype">int</span>)s-&gt;<a class="code" href="struct__fluid__sample__t.html#708e728c1dd67bb62a70e4edd7fc1f1c">loopstart</a>; i &lt; (<span class="keywordtype">int</span>) s-&gt;<a class="code" href="struct__fluid__sample__t.html#3baa4ca199a55b77c2692d9d3211e0d0">loopend</a>; i ++){
<a name="l01972"></a>01972       <span class="keywordtype">signed</span> <span class="keywordtype">short</span> val = s-&gt;<a class="code" href="struct__fluid__sample__t.html#8c7262f51500369fd1a3e5306b458d55">data</a>[i];
<a name="l01973"></a>01973       <span class="keywordflow">if</span> (val &gt; peak_max) {
<a name="l01974"></a>01974         peak_max = val;
<a name="l01975"></a>01975       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &lt; peak_min) {
<a name="l01976"></a>01976         peak_min = val;
<a name="l01977"></a>01977       }
<a name="l01978"></a>01978     }
<a name="l01979"></a>01979 
<a name="l01980"></a>01980     <span class="comment">/* Determine the peak level */</span>
<a name="l01981"></a>01981     <span class="keywordflow">if</span> (peak_max &gt;- peak_min){
<a name="l01982"></a>01982       peak = peak_max;
<a name="l01983"></a>01983     } <span class="keywordflow">else</span> {
<a name="l01984"></a>01984       peak =- peak_min;
<a name="l01985"></a>01985     };
<a name="l01986"></a>01986     <span class="keywordflow">if</span> (peak == 0){
<a name="l01987"></a>01987       <span class="comment">/* Avoid division by zero */</span>
<a name="l01988"></a>01988       peak = 1;
<a name="l01989"></a>01989     };
<a name="l01990"></a>01990 
<a name="l01991"></a>01991     <span class="comment">/* Calculate what factor will make the loop inaudible</span>
<a name="l01992"></a>01992 <span class="comment">     * For example: Take a peak of 3277 (10 % of 32768).  The</span>
<a name="l01993"></a>01993 <span class="comment">     * normalized amplitude is 0.1 (10 % of 32768).  An amplitude</span>
<a name="l01994"></a>01994 <span class="comment">     * factor of 0.0001 (as opposed to the default 0.00001) will</span>
<a name="l01995"></a>01995 <span class="comment">     * drop this sample to the noise floor.</span>
<a name="l01996"></a>01996 <span class="comment">     */</span>
<a name="l01997"></a>01997 
<a name="l01998"></a>01998     <span class="comment">/* 16 bits =&gt; 96+4=100 dB dynamic range =&gt; 0.00001 */</span>
<a name="l01999"></a>01999     normalized_amplitude_during_loop = ((fluid_real_t)peak)/32768.;
<a name="l02000"></a>02000     result = FLUID_NOISE_FLOOR / normalized_amplitude_during_loop;
<a name="l02001"></a>02001 
<a name="l02002"></a>02002     <span class="comment">/* Store in sample */</span>
<a name="l02003"></a>02003     s-&gt;<a class="code" href="struct__fluid__sample__t.html#91eee4970ca353df88665c0c3119e841">amplitude_that_reaches_noise_floor</a> = (double)result;
<a name="l02004"></a>02004     s-&gt;<a class="code" href="struct__fluid__sample__t.html#c054e203acd07ad158256e343f1fd0a5" title="The amplitude, that will lower the level of the sample&amp;#39;s loop to the noise floor...">amplitude_that_reaches_noise_floor_is_valid</a> = 1;
<a name="l02005"></a>02005 <span class="preprocessor">#if 0</span>
<a name="l02006"></a>02006 <span class="preprocessor"></span>    printf(<span class="stringliteral">"Sample peak detection: factor %f\n"</span>, (<span class="keywordtype">double</span>)result);
<a name="l02007"></a>02007 <span class="preprocessor">#endif</span>
<a name="l02008"></a>02008 <span class="preprocessor"></span>  };
<a name="l02009"></a>02009   <span class="keywordflow">return</span> FLUID_OK;
<a name="l02010"></a>02010 }
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 17 13:40:24 2007 for libfluidsynth by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
