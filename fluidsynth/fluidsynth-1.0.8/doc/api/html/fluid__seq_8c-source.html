<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libfluidsynth: src/fluid_seq.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>src/fluid_seq.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* FluidSynth - A Software Synthesizer</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (C) 2003  Peter Hanappe and others.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment"> * modify it under the terms of the GNU Library General Public License</span>
<a name="l00007"></a>00007 <span class="comment"> * as published by the Free Software Foundation; either version 2 of</span>
<a name="l00008"></a>00008 <span class="comment"> * the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This library is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * Library General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * You should have received a copy of the GNU Library General Public</span>
<a name="l00016"></a>00016 <span class="comment"> * License along with this library; if not, write to the Free</span>
<a name="l00017"></a>00017 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</span>
<a name="l00018"></a>00018 <span class="comment"> * 02111-1307, USA</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/*</span>
<a name="l00024"></a>00024 <span class="comment">  2002 : API design by Peter Hanappe and Antoine Schmitt</span>
<a name="l00025"></a>00025 <span class="comment">  August 2002 : Implementation by Antoine Schmitt as@gratin.org</span>
<a name="l00026"></a>00026 <span class="comment">  as part of the infiniteCD author project</span>
<a name="l00027"></a>00027 <span class="comment">  http://www.infiniteCD.org/</span>
<a name="l00028"></a>00028 <span class="comment">*/</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include "fluid_event_priv.h"</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include "fluidsynth_priv.h"</span>    <span class="comment">// FLUID_NEW, etc</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include "fluid_sys.h"</span>  <span class="comment">// timer, threads, etc...</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include "fluid_list.h"</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">/***************************************************************</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> *                           SEQUENCER</span>
<a name="l00038"></a>00038 <span class="comment"> */</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#define FLUID_SEQUENCER_EVENTS_MAX      1000</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="comment">/* Private data for SEQUENCER */</span>
<a name="l00043"></a>00043 <span class="keyword">struct </span>_fluid_sequencer_t {
<a name="l00044"></a>00044         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> startMs;
<a name="l00045"></a>00045         <span class="keywordtype">double</span> scale; <span class="comment">// ticks per second</span>
<a name="l00046"></a>00046         fluid_list_t* clients;
<a name="l00047"></a>00047         <span class="keywordtype">short</span> clientsID;
<a name="l00048"></a>00048         <span class="comment">/* for queue + heap */</span>
<a name="l00049"></a>00049         fluid_evt_entry* preQueue;
<a name="l00050"></a>00050         fluid_evt_entry* preQueueLast;
<a name="l00051"></a>00051         fluid_timer_t* timer;
<a name="l00052"></a>00052         <span class="keywordtype">int</span> queue0StartTime;
<a name="l00053"></a>00053         <span class="keywordtype">short</span> prevCellNb;
<a name="l00054"></a>00054         fluid_evt_entry* queue0[256][2];
<a name="l00055"></a>00055         fluid_evt_entry* queue1[255][2];
<a name="l00056"></a>00056         fluid_evt_entry* queueLater;
<a name="l00057"></a>00057         fluid_evt_heap_t* heap;
<a name="l00058"></a>00058         fluid_mutex_t mutex;
<a name="l00059"></a>00059 <span class="preprocessor">#if FLUID_SEQ_WITH_TRACE</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>        <span class="keywordtype">char</span> *tracebuf;
<a name="l00061"></a>00061         <span class="keywordtype">char</span> *traceptr;
<a name="l00062"></a>00062         <span class="keywordtype">int</span> tracelen;
<a name="l00063"></a>00063 <span class="preprocessor">#endif</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>};
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">/* Private data for clients */</span>
<a name="l00067"></a>00067 <span class="keyword">typedef</span> <span class="keyword">struct </span>_fluid_sequencer_client_t {
<a name="l00068"></a>00068         <span class="keywordtype">short</span> id;
<a name="l00069"></a>00069         <span class="keywordtype">char</span>* name;
<a name="l00070"></a>00070         fluid_event_callback_t callback;
<a name="l00071"></a>00071         <span class="keywordtype">void</span>* data;
<a name="l00072"></a>00072 } fluid_sequencer_client_t;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">/* prototypes */</span>
<a name="l00075"></a>00075 <span class="comment">/* sorting API */</span>
<a name="l00076"></a>00076 <span class="keywordtype">short</span> _fluid_seq_queue_init(fluid_sequencer_t* seq, <span class="keywordtype">int</span> nbEvents);
<a name="l00077"></a>00077 <span class="keywordtype">void</span> _fluid_seq_queue_end(fluid_sequencer_t* seq);
<a name="l00078"></a>00078 <span class="keywordtype">short</span> _fluid_seq_queue_pre_insert(fluid_sequencer_t* seq, fluid_event_t * evt);
<a name="l00079"></a>00079 <span class="keywordtype">void</span> _fluid_seq_queue_pre_remove(fluid_sequencer_t* seq, <span class="keywordtype">short</span> src, <span class="keywordtype">short</span> dest, <span class="keywordtype">int</span> type);
<a name="l00080"></a>00080 <span class="keywordtype">int</span> _fluid_seq_queue_process(<span class="keywordtype">void</span>* data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msec); <span class="comment">// callback from timer</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">/* API implementation */</span>
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 fluid_sequencer_t*
<a name="l00086"></a>00086 new_fluid_sequencer()
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088         fluid_sequencer_t* seq;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090         seq = FLUID_NEW(fluid_sequencer_t);
<a name="l00091"></a>00091         <span class="keywordflow">if</span> (seq == NULL) {
<a name="l00092"></a>00092                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: Out of memory\n"</span>);
<a name="l00093"></a>00093                 <span class="keywordflow">return</span> NULL;
<a name="l00094"></a>00094         }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         FLUID_MEMSET(seq, 0, <span class="keyword">sizeof</span>(fluid_sequencer_t));
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         seq-&gt;scale = 1000;      <span class="comment">// default value</span>
<a name="l00099"></a>00099         seq-&gt;startMs = fluid_curtime();
<a name="l00100"></a>00100         seq-&gt;clients = NULL;
<a name="l00101"></a>00101         seq-&gt;clientsID = 0;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103         <span class="keywordflow">if</span> (-1 == _fluid_seq_queue_init(seq, FLUID_SEQUENCER_EVENTS_MAX)) {
<a name="l00104"></a>00104                 FLUID_FREE(seq);
<a name="l00105"></a>00105                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: Out of memory\n"</span>);
<a name="l00106"></a>00106                 <span class="keywordflow">return</span> NULL;
<a name="l00107"></a>00107         }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#if FLUID_SEQ_WITH_TRACE</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>        seq-&gt;tracelen = 1024*100;
<a name="l00111"></a>00111         seq-&gt;tracebuf = (<span class="keywordtype">char</span> *)FLUID_MALLOC(seq-&gt;tracelen);
<a name="l00112"></a>00112         <span class="keywordflow">if</span> (seq-&gt;tracebuf == NULL) {
<a name="l00113"></a>00113                 _fluid_seq_queue_end(seq);
<a name="l00114"></a>00114                 FLUID_FREE(seq);
<a name="l00115"></a>00115                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: Out of memory\n"</span>);
<a name="l00116"></a>00116                 <span class="keywordflow">return</span> NULL;
<a name="l00117"></a>00117         }
<a name="l00118"></a>00118         seq-&gt;traceptr = seq-&gt;tracebuf;
<a name="l00119"></a>00119 <span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121         <span class="keywordflow">return</span>(seq);
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keywordtype">void</span>
<a name="l00125"></a>00125 delete_fluid_sequencer(fluid_sequencer_t* seq)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="keywordflow">if</span> (seq == NULL) {
<a name="l00129"></a>00129                 <span class="keywordflow">return</span>;
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         _fluid_seq_queue_end(seq);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <span class="comment">/* cleanup clients */</span>
<a name="l00135"></a>00135         <span class="keywordflow">if</span> (seq-&gt;clients) {
<a name="l00136"></a>00136                 fluid_list_t *tmp = seq-&gt;clients;
<a name="l00137"></a>00137                 <span class="keywordflow">while</span> (tmp != NULL) {
<a name="l00138"></a>00138                         fluid_sequencer_client_t *client = (fluid_sequencer_client_t*)tmp-&gt;data;
<a name="l00139"></a>00139                         if (client-&gt;name) FLUID_FREE(client-&gt;name);
<a name="l00140"></a>00140                         tmp = tmp-&gt;next;
<a name="l00141"></a>00141                 }
<a name="l00142"></a>00142                 delete_fluid_list(seq-&gt;clients);
<a name="l00143"></a>00143                 seq-&gt;clients = NULL;
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="preprocessor">#if FLUID_SEQ_WITH_TRACE</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (seq-&gt;tracebuf != NULL)
<a name="l00148"></a>00148                 FLUID_FREE(seq-&gt;tracebuf);
<a name="l00149"></a>00149         seq-&gt;tracebuf = NULL;
<a name="l00150"></a>00150 <span class="preprocessor">#endif</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>
<a name="l00152"></a>00152         FLUID_FREE(seq);
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="preprocessor">#if FLUID_SEQ_WITH_TRACE</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span>
<a name="l00157"></a>00157 <span class="comment">/* trace */</span>
<a name="l00158"></a>00158 <span class="keywordtype">void</span>
<a name="l00159"></a>00159 fluid_seq_dotrace(fluid_sequencer_t* seq, <span class="keywordtype">char</span> *fmt, ...)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161         va_list args;
<a name="l00162"></a>00162         <span class="keywordtype">int</span> len, remain = seq-&gt;tracelen - (seq-&gt;traceptr - seq-&gt;tracebuf);
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (remain &lt;= 0) <span class="keywordflow">return</span>;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         va_start (args, fmt);
<a name="l00166"></a>00166         len = vsnprintf(seq-&gt;traceptr, remain, fmt, args);
<a name="l00167"></a>00167         va_end (args);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         <span class="keywordflow">if</span> (len &gt; 0) {
<a name="l00170"></a>00170                 <span class="keywordflow">if</span> (len &lt;= remain) {
<a name="l00171"></a>00171                         <span class="comment">// all written, with 0 at end</span>
<a name="l00172"></a>00172                         seq-&gt;traceptr += len;
<a name="l00173"></a>00173                 } <span class="keywordflow">else</span> {
<a name="l00174"></a>00174                         <span class="comment">// not enough room, set to end</span>
<a name="l00175"></a>00175                         seq-&gt;traceptr = seq-&gt;tracebuf + seq-&gt;tracelen;
<a name="l00176"></a>00176                 }
<a name="l00177"></a>00177         }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         <span class="keywordflow">return</span>;
<a name="l00180"></a>00180 }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="keywordtype">void</span>
<a name="l00183"></a>00183 fluid_seq_cleartrace(fluid_sequencer_t* seq)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185         seq-&gt;traceptr = seq-&gt;tracebuf;
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keywordtype">char</span> *
<a name="l00189"></a>00189 fluid_seq_gettrace(fluid_sequencer_t* seq)
<a name="l00190"></a>00190 {
<a name="l00191"></a>00191         <span class="keywordflow">return</span> seq-&gt;tracebuf;
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 <span class="preprocessor">#else</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00195"></a>00195 <span class="keywordtype">void</span> fluid_seq_dotrace(fluid_sequencer_t* seq, <span class="keywordtype">char</span> *fmt, ...) {}
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="preprocessor">#endif // FLUID_SEQ_WITH_TRACE</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span>
<a name="l00199"></a>00199 <span class="comment">/* clients */</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="keywordtype">short</span> fluid_sequencer_register_client(fluid_sequencer_t* seq, <span class="keywordtype">char</span>* name,
<a name="l00202"></a>00202                                       fluid_event_callback_t callback, <span class="keywordtype">void</span>* data) {
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         fluid_sequencer_client_t * client;
<a name="l00205"></a>00205         <span class="keywordtype">char</span> * nameCopy;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         client = FLUID_NEW(fluid_sequencer_client_t);
<a name="l00208"></a>00208         <span class="keywordflow">if</span> (client == NULL) {
<a name="l00209"></a>00209                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: Out of memory\n"</span>);
<a name="l00210"></a>00210                 <span class="keywordflow">return</span> -1;
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213         nameCopy = FLUID_STRDUP(name);
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (nameCopy == NULL) {
<a name="l00215"></a>00215                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: Out of memory\n"</span>);
<a name="l00216"></a>00216                 <span class="keywordflow">return</span> -1;
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         seq-&gt;clientsID++;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         client-&gt;name = nameCopy;
<a name="l00222"></a>00222         client-&gt;id = seq-&gt;clientsID;
<a name="l00223"></a>00223         client-&gt;callback = callback;
<a name="l00224"></a>00224         client-&gt;data = data;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         seq-&gt;clients = fluid_list_append(seq-&gt;clients, (<span class="keywordtype">void</span> *)client);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="keywordflow">return</span> (client-&gt;id);
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00232"></a>00232 <span class="keywordtype">void</span> fluid_sequencer_unregister_client(fluid_sequencer_t* seq, <span class="keywordtype">short</span> <span class="keywordtype">id</span>)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234         fluid_list_t *tmp;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <span class="keywordflow">if</span> (seq-&gt;clients == NULL) <span class="keywordflow">return</span>;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         tmp = seq-&gt;clients;
<a name="l00239"></a>00239         <span class="keywordflow">while</span> (tmp) {
<a name="l00240"></a>00240                 fluid_sequencer_client_t *client = (fluid_sequencer_client_t*)tmp-&gt;data;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242                 if (client-&gt;id == <span class="keywordtype">id</span>) {
<a name="l00243"></a>00243                         <span class="keywordflow">if</span> (client-&gt;name)
<a name="l00244"></a>00244                                 FLUID_FREE(client-&gt;name);
<a name="l00245"></a>00245                         seq-&gt;clients = fluid_list_remove_link(seq-&gt;clients, tmp);
<a name="l00246"></a>00246                         delete1_fluid_list(tmp);
<a name="l00247"></a>00247                         <span class="keywordflow">return</span>;
<a name="l00248"></a>00248                 }
<a name="l00249"></a>00249                 tmp = tmp-&gt;next;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251         <span class="keywordflow">return</span>;
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="keywordtype">int</span> fluid_sequencer_count_clients(fluid_sequencer_t* seq)
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256         <span class="keywordflow">if</span> (seq-&gt;clients == NULL)
<a name="l00257"></a>00257                 <span class="keywordflow">return</span> 0;
<a name="l00258"></a>00258         <span class="keywordflow">return</span> fluid_list_size(seq-&gt;clients);
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00262"></a>00262 <span class="keywordtype">short</span> fluid_sequencer_get_client_id(fluid_sequencer_t* seq, <span class="keywordtype">int</span> index)
<a name="l00263"></a>00263 {
<a name="l00264"></a>00264         fluid_list_t *tmp = fluid_list_nth(seq-&gt;clients, index);
<a name="l00265"></a>00265         <span class="keywordflow">if</span> (tmp == NULL) {
<a name="l00266"></a>00266                 <span class="keywordflow">return</span> -1;
<a name="l00267"></a>00267         } <span class="keywordflow">else</span> {
<a name="l00268"></a>00268                 fluid_sequencer_client_t *client = (fluid_sequencer_client_t*)tmp-&gt;data;
<a name="l00269"></a>00269                 <span class="keywordflow">return</span> client-&gt;id;
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00274"></a>00274 <span class="keywordtype">char</span>* fluid_sequencer_get_client_name(fluid_sequencer_t* seq, <span class="keywordtype">int</span> <span class="keywordtype">id</span>)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276         fluid_list_t *tmp;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <span class="keywordflow">if</span> (seq-&gt;clients == NULL)
<a name="l00279"></a>00279                 <span class="keywordflow">return</span> NULL;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281         tmp = seq-&gt;clients;
<a name="l00282"></a>00282         <span class="keywordflow">while</span> (tmp) {
<a name="l00283"></a>00283                 fluid_sequencer_client_t *client = (fluid_sequencer_client_t*)tmp-&gt;data;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285                 if (client-&gt;id == <span class="keywordtype">id</span>)
<a name="l00286"></a>00286                         <span class="keywordflow">return</span> client-&gt;name;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288                 tmp = tmp-&gt;next;
<a name="l00289"></a>00289         }
<a name="l00290"></a>00290         <span class="keywordflow">return</span> NULL;
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="keywordtype">int</span> fluid_sequencer_client_is_dest(fluid_sequencer_t* seq, <span class="keywordtype">int</span> <span class="keywordtype">id</span>)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295         fluid_list_t *tmp;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297         <span class="keywordflow">if</span> (seq-&gt;clients == NULL) <span class="keywordflow">return</span> 0;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         tmp = seq-&gt;clients;
<a name="l00300"></a>00300         <span class="keywordflow">while</span> (tmp) {
<a name="l00301"></a>00301                 fluid_sequencer_client_t *client = (fluid_sequencer_client_t*)tmp-&gt;data;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303                 if (client-&gt;id == <span class="keywordtype">id</span>)
<a name="l00304"></a>00304                         <span class="keywordflow">return</span> (client-&gt;callback != NULL);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306                 tmp = tmp-&gt;next;
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308         <span class="keywordflow">return</span> 0;
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="comment">/* sending events */</span>
<a name="l00312"></a>00312 <span class="keywordtype">void</span> fluid_sequencer_send_now(fluid_sequencer_t* seq, fluid_event_t* evt)
<a name="l00313"></a>00313 {
<a name="l00314"></a>00314         <span class="keywordtype">short</span> destID = <a class="code" href="event_8h.html#e55407a115f1efdfefd8cd5ba58faae9" title="Get the dest field from a sequencer event structure.">fluid_event_get_dest</a>(evt);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316         <span class="comment">/* find callback */</span>
<a name="l00317"></a>00317         fluid_list_t *tmp = seq-&gt;clients;
<a name="l00318"></a>00318         <span class="keywordflow">while</span> (tmp) {
<a name="l00319"></a>00319                 fluid_sequencer_client_t *dest = (fluid_sequencer_client_t*)tmp-&gt;data;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321                 if (dest-&gt;id == destID) {
<a name="l00322"></a>00322                         <span class="keywordflow">if</span> (dest-&gt;callback)
<a name="l00323"></a>00323                                 (dest-&gt;callback)(fluid_sequencer_get_tick(seq),
<a name="l00324"></a>00324                                                  evt, seq, dest-&gt;data);
<a name="l00325"></a>00325                         <span class="keywordflow">return</span>;
<a name="l00326"></a>00326                 }
<a name="l00327"></a>00327                 tmp = tmp-&gt;next;
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329 }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 <span class="keywordtype">int</span>
<a name="l00332"></a>00332 fluid_sequencer_send_at(fluid_sequencer_t* seq, fluid_event_t* evt, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time, <span class="keywordtype">int</span> absolute)
<a name="l00333"></a>00333 {
<a name="l00334"></a>00334         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> now = fluid_sequencer_get_tick(seq);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         <span class="comment">/* set absolute */</span>
<a name="l00337"></a>00337         <span class="keywordflow">if</span> (!absolute)
<a name="l00338"></a>00338                 time = now + time;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="comment">/* time stamp event */</span>
<a name="l00341"></a>00341         fluid_event_set_time(evt, time);
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         <span class="comment">/* process late */</span>
<a name="l00344"></a>00344         <span class="keywordflow">if</span> (time &lt; now) {
<a name="l00345"></a>00345                 fluid_sequencer_send_now(seq, evt);
<a name="l00346"></a>00346                 <span class="keywordflow">return</span> 0;
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         <span class="comment">/* process now */</span>
<a name="l00350"></a>00350         <span class="keywordflow">if</span> (time == now) {
<a name="l00351"></a>00351                 fluid_sequencer_send_now(seq, evt);
<a name="l00352"></a>00352                 <span class="keywordflow">return</span> 0;
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="comment">/* queue for processing later */</span>
<a name="l00356"></a>00356         <span class="keywordflow">return</span> _fluid_seq_queue_pre_insert(seq, evt);
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="keywordtype">void</span>
<a name="l00360"></a>00360 fluid_sequencer_remove_events(fluid_sequencer_t* seq, <span class="keywordtype">short</span> source, <span class="keywordtype">short</span> dest, <span class="keywordtype">int</span> type)
<a name="l00361"></a>00361 {
<a name="l00362"></a>00362         _fluid_seq_queue_pre_remove(seq, source, dest, type);
<a name="l00363"></a>00363 }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="comment">/*************************************</span>
<a name="l00367"></a>00367 <span class="comment">        time</span>
<a name="l00368"></a>00368 <span class="comment">**************************************/</span>
<a name="l00369"></a>00369 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_sequencer_get_tick(fluid_sequencer_t* seq)
<a name="l00370"></a>00370 {
<a name="l00371"></a>00371         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> absMs = fluid_curtime();
<a name="l00372"></a>00372         <span class="keywordtype">double</span> nowFloat;
<a name="l00373"></a>00373         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> now;
<a name="l00374"></a>00374         nowFloat = ((double)(absMs - seq-&gt;startMs))*seq-&gt;scale/1000.0f;
<a name="l00375"></a>00375         now = nowFloat;
<a name="l00376"></a>00376         <span class="keywordflow">return</span> now;
<a name="l00377"></a>00377 }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="keywordtype">void</span> fluid_sequencer_set_time_scale(fluid_sequencer_t* seq, <span class="keywordtype">double</span> scale)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381         <span class="keywordflow">if</span> (scale &lt;= 0) {
<a name="l00382"></a>00382                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e394460be1ec74fce15e1ff683606df0f" title="Warning.">FLUID_WARN</a>, <span class="stringliteral">"sequencer: scale &lt;= 0 : %f\n"</span>, scale);
<a name="l00383"></a>00383                 <span class="keywordflow">return</span>;
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         <span class="keywordflow">if</span> (scale &gt; 1000.0)
<a name="l00387"></a>00387                 <span class="comment">// Otherwise : problems with the timer = 0ms...</span>
<a name="l00388"></a>00388                 scale = 1000.0;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (seq-&gt;scale != scale) {
<a name="l00391"></a>00391                 <span class="keywordtype">double</span> oldScale = seq-&gt;scale;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393                 <span class="comment">// stop timer</span>
<a name="l00394"></a>00394                 <span class="keywordflow">if</span> (seq-&gt;timer) {
<a name="l00395"></a>00395                         delete_fluid_timer(seq-&gt;timer);
<a name="l00396"></a>00396                         seq-&gt;timer = NULL;
<a name="l00397"></a>00397                 }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399                 seq-&gt;scale = scale;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401                 <span class="comment">// change start0 so that cellNb is preserved</span>
<a name="l00402"></a>00402                 seq-&gt;queue0StartTime =  (seq-&gt;queue0StartTime + seq-&gt;prevCellNb)*(seq-&gt;scale/oldScale) - seq-&gt;prevCellNb;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                 <span class="comment">// change all preQueue events for new scale</span>
<a name="l00405"></a>00405                 {
<a name="l00406"></a>00406                         fluid_evt_entry* tmp;
<a name="l00407"></a>00407                         tmp = seq-&gt;preQueue;
<a name="l00408"></a>00408                         <span class="keywordflow">while</span> (tmp) {
<a name="l00409"></a>00409                                 <span class="keywordflow">if</span> (tmp-&gt;entryType == FLUID_EVT_ENTRY_INSERT)
<a name="l00410"></a>00410                                         tmp-&gt;evt.time = tmp-&gt;evt.time*seq-&gt;scale/oldScale;
<a name="l00411"></a>00411 
<a name="l00412"></a>00412                                 tmp = tmp-&gt;next;
<a name="l00413"></a>00413                         }
<a name="l00414"></a>00414                 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416                 <span class="comment">/* re-start timer */</span>
<a name="l00417"></a>00417                 seq-&gt;timer = new_fluid_timer((<span class="keywordtype">int</span>)(1000/seq-&gt;scale), _fluid_seq_queue_process, (<span class="keywordtype">void</span> *)seq, 1, 0);
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00423"></a>00423 <span class="keywordtype">double</span> fluid_sequencer_get_time_scale(fluid_sequencer_t* seq)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425         <span class="keywordflow">return</span> seq-&gt;scale;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="comment">/**********************</span>
<a name="l00430"></a>00430 <span class="comment"></span>
<a name="l00431"></a>00431 <span class="comment">      the queue</span>
<a name="l00432"></a>00432 <span class="comment"></span>
<a name="l00433"></a>00433 <span class="comment">**********************/</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="comment">/*</span>
<a name="l00436"></a>00436 <span class="comment">  The queue stores all future events to be processed.</span>
<a name="l00437"></a>00437 <span class="comment"></span>
<a name="l00438"></a>00438 <span class="comment">  Data structures</span>
<a name="l00439"></a>00439 <span class="comment"></span>
<a name="l00440"></a>00440 <span class="comment">  There is a heap, allocated at init time, for managing a pool</span>
<a name="l00441"></a>00441 <span class="comment">  of event entries, that is description of an event, its time,</span>
<a name="l00442"></a>00442 <span class="comment">  and whether it is a normal event or a removal command.</span>
<a name="l00443"></a>00443 <span class="comment"></span>
<a name="l00444"></a>00444 <span class="comment">  The queue is separated in two arrays, and a list.  The first</span>
<a name="l00445"></a>00445 <span class="comment">  array 'queue0' corresponds to the events to be sent in the</span>
<a name="l00446"></a>00446 <span class="comment">  next 256 ticks (0 to 255), the second array 'queue1' contains</span>
<a name="l00447"></a>00447 <span class="comment">  the events to be send from now+256 to now+65535. The list</span>
<a name="l00448"></a>00448 <span class="comment">  called 'queueLater' contains the events to be sent later than</span>
<a name="l00449"></a>00449 <span class="comment">  that. In each array, one cell contains a list of events having</span>
<a name="l00450"></a>00450 <span class="comment">  the same time (in the queue0 array), or the same time/256 (in</span>
<a name="l00451"></a>00451 <span class="comment">  the queue1 array), and a pointer to the last event in the list</span>
<a name="l00452"></a>00452 <span class="comment">  of the cell so as to be able to insert fast at the end of the</span>
<a name="l00453"></a>00453 <span class="comment">  list (i.e. a cell = 2 pointers).  The 'queueLater' list is</span>
<a name="l00454"></a>00454 <span class="comment">  ordered by time and by post time.  This way, inserting 'soon'</span>
<a name="l00455"></a>00455 <span class="comment">  events is fast (below 65535 ticks, that is about 1 minute if 1</span>
<a name="l00456"></a>00456 <span class="comment">  tick=1ms).  Inserting later events is more slow, but this is a</span>
<a name="l00457"></a>00457 <span class="comment">  realtime engine, isn't it ?</span>
<a name="l00458"></a>00458 <span class="comment"></span>
<a name="l00459"></a>00459 <span class="comment">  The queue0 starts at queue0StartTime.  When 256 ticks have</span>
<a name="l00460"></a>00460 <span class="comment">  elapsed, the queue0 array is emptied, and the first cell of</span>
<a name="l00461"></a>00461 <span class="comment">  the queue1 array is expanded in the queue0 array, according to</span>
<a name="l00462"></a>00462 <span class="comment">  the time of each event. The queue1 array is shifted to the</span>
<a name="l00463"></a>00463 <span class="comment">  left, and the first events of the queueLater list are inserte</span>
<a name="l00464"></a>00464 <span class="comment">  in the last cell of the queue1 array.</span>
<a name="l00465"></a>00465 <span class="comment"></span>
<a name="l00466"></a>00466 <span class="comment">  We remember the previously managed cell in queue0 in the</span>
<a name="l00467"></a>00467 <span class="comment">  prevCellNb variable. When processing the current cell, we</span>
<a name="l00468"></a>00468 <span class="comment">  process the events in between (late events).</span>
<a name="l00469"></a>00469 <span class="comment"></span>
<a name="l00470"></a>00470 <span class="comment">  Functions</span>
<a name="l00471"></a>00471 <span class="comment"></span>
<a name="l00472"></a>00472 <span class="comment">  The main thread functions first get an event entry from the</span>
<a name="l00473"></a>00473 <span class="comment">  heap, and copy the given event into it, then merely enqueue it</span>
<a name="l00474"></a>00474 <span class="comment">  in a preQueue. This is in order to protect the data structure:</span>
<a name="l00475"></a>00475 <span class="comment">  everything is managed in the callback (thread or interrupt,</span>
<a name="l00476"></a>00476 <span class="comment">  depending on the architecture).</span>
<a name="l00477"></a>00477 <span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">  All queue data structure management is done in a timer</span>
<a name="l00479"></a>00479 <span class="comment">  callback: '_fluid_seq_queue_process'.  The</span>
<a name="l00480"></a>00480 <span class="comment">  _fluid_seq_queue_process function first process the preQueue,</span>
<a name="l00481"></a>00481 <span class="comment">  inserting or removing event entrys from the queue, then</span>
<a name="l00482"></a>00482 <span class="comment">  processes the queue, by sending events ready to be sent at the</span>
<a name="l00483"></a>00483 <span class="comment">  current time.</span>
<a name="l00484"></a>00484 <span class="comment"></span>
<a name="l00485"></a>00485 <span class="comment">  Critical sections between the main thread (or app) and the</span>
<a name="l00486"></a>00486 <span class="comment">  sequencer thread (or interrupt) are:</span>
<a name="l00487"></a>00487 <span class="comment"></span>
<a name="l00488"></a>00488 <span class="comment">  - the heap management (if two threads get a free event at the</span>
<a name="l00489"></a>00489 <span class="comment">  same time)</span>
<a name="l00490"></a>00490 <span class="comment">  - the preQueue access.</span>
<a name="l00491"></a>00491 <span class="comment"></span>
<a name="l00492"></a>00492 <span class="comment">  These are really small and fast sections (merely a pointer or</span>
<a name="l00493"></a>00493 <span class="comment">  two changing value). They are not protected by a mutex for now</span>
<a name="l00494"></a>00494 <span class="comment">  (August 2002). Waiting for crossplatform mutex solutions. When</span>
<a name="l00495"></a>00495 <span class="comment">  changing this code, beware that the</span>
<a name="l00496"></a>00496 <span class="comment">  _fluid_seq_queue_pre_insert function may be called by the</span>
<a name="l00497"></a>00497 <span class="comment">  callback of the queue thread (ex : a note event inserts a</span>
<a name="l00498"></a>00498 <span class="comment">  noteoff event).</span>
<a name="l00499"></a>00499 <span class="comment"></span>
<a name="l00500"></a>00500 <span class="comment">*/</span>
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="keywordtype">void</span> _fluid_seq_queue_insert_entry(fluid_sequencer_t* seq, fluid_evt_entry * evtentry);
<a name="l00505"></a>00505 <span class="keywordtype">void</span> _fluid_seq_queue_remove_entries_matching(fluid_sequencer_t* seq, fluid_evt_entry* temp);
<a name="l00506"></a>00506 <span class="keywordtype">void</span> _fluid_seq_queue_send_queued_events(fluid_sequencer_t* seq);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="comment">/********************/</span>
<a name="l00510"></a>00510 <span class="comment">/*       API        */</span>
<a name="l00511"></a>00511 <span class="comment">/********************/</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="keywordtype">short</span>
<a name="l00514"></a>00514 _fluid_seq_queue_init(fluid_sequencer_t* seq, <span class="keywordtype">int</span> maxEvents)
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516         <span class="keywordtype">int</span> i;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         seq-&gt;heap = _fluid_evt_heap_init(maxEvents);
<a name="l00519"></a>00519         <span class="keywordflow">if</span> (seq-&gt;heap == NULL) {
<a name="l00520"></a>00520                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: Out of memory\n"</span>);
<a name="l00521"></a>00521                 <span class="keywordflow">return</span> -1;
<a name="l00522"></a>00522         }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         seq-&gt;preQueue = NULL;
<a name="l00525"></a>00525         seq-&gt;preQueueLast = NULL;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         FLUID_MEMSET(seq-&gt;queue0, 0, 2*256*<span class="keyword">sizeof</span>(fluid_evt_entry *));
<a name="l00528"></a>00528         FLUID_MEMSET(seq-&gt;queue1, 0, 2*255*<span class="keyword">sizeof</span>(fluid_evt_entry *));
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         seq-&gt;queueLater = NULL;
<a name="l00531"></a>00531         seq-&gt;queue0StartTime = fluid_sequencer_get_tick(seq);
<a name="l00532"></a>00532         seq-&gt;prevCellNb = -1;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         fluid_mutex_init(seq-&gt;mutex);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="comment">/* start timer */</span>
<a name="l00537"></a>00537         seq-&gt;timer = new_fluid_timer((<span class="keywordtype">int</span>)(1000/seq-&gt;scale), _fluid_seq_queue_process,
<a name="l00538"></a>00538                                      (<span class="keywordtype">void</span> *)seq, 1, 0);
<a name="l00539"></a>00539         <span class="keywordflow">return</span> (0);
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="keywordtype">void</span>
<a name="l00543"></a>00543 _fluid_seq_queue_end(fluid_sequencer_t* seq)
<a name="l00544"></a>00544 {
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (seq-&gt;timer) {
<a name="l00546"></a>00546                 delete_fluid_timer(seq-&gt;timer);
<a name="l00547"></a>00547                 seq-&gt;timer = NULL;
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (seq-&gt;heap) {
<a name="l00551"></a>00551                 _fluid_evt_heap_free(seq-&gt;heap);
<a name="l00552"></a>00552                 seq-&gt;heap = NULL;
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554         fluid_mutex_destroy(seq-&gt;mutex);
<a name="l00555"></a>00555 }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="comment">/********************/</span>
<a name="l00560"></a>00560 <span class="comment">/* queue management */</span>
<a name="l00561"></a>00561 <span class="comment">/********************/</span>
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">/* create event_entry and append to the preQueue */</span>
<a name="l00564"></a>00564 <span class="comment">/* may be called from the main thread (usually) but also recursively</span>
<a name="l00565"></a>00565 <span class="comment">   from the queue thread, when a callback itself does an insert... */</span>
<a name="l00566"></a>00566 <span class="keywordtype">short</span>
<a name="l00567"></a>00567 _fluid_seq_queue_pre_insert(fluid_sequencer_t* seq, fluid_event_t * evt)
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569         fluid_evt_entry * evtentry = _fluid_seq_heap_get_free(seq-&gt;heap);
<a name="l00570"></a>00570         <span class="keywordflow">if</span> (evtentry == NULL) {
<a name="l00571"></a>00571                 <span class="comment">/* should not happen */</span>
<a name="l00572"></a>00572                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: no more free events\n"</span>);
<a name="l00573"></a>00573                 <span class="keywordflow">return</span> -1;
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576         evtentry-&gt;next = NULL;
<a name="l00577"></a>00577         evtentry-&gt;entryType = FLUID_EVT_ENTRY_INSERT;
<a name="l00578"></a>00578         FLUID_MEMCPY(&amp;(evtentry-&gt;evt), evt, <span class="keyword">sizeof</span>(fluid_event_t));
<a name="l00579"></a>00579 
<a name="l00580"></a>00580         fluid_mutex_lock(seq-&gt;mutex);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582         <span class="comment">/* append to preQueue */</span>
<a name="l00583"></a>00583         <span class="keywordflow">if</span> (seq-&gt;preQueueLast) {
<a name="l00584"></a>00584                 seq-&gt;preQueueLast-&gt;next = evtentry;
<a name="l00585"></a>00585         } <span class="keywordflow">else</span> {
<a name="l00586"></a>00586                 seq-&gt;preQueue = evtentry;
<a name="l00587"></a>00587         }
<a name="l00588"></a>00588         seq-&gt;preQueueLast = evtentry;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         fluid_mutex_unlock(seq-&gt;mutex);
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <span class="keywordflow">return</span> (0);
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="comment">/* create event_entry and append to the preQueue */</span>
<a name="l00596"></a>00596 <span class="comment">/* may be called from the main thread (usually) but also recursively</span>
<a name="l00597"></a>00597 <span class="comment">   from the queue thread, when a callback itself does an insert... */</span>
<a name="l00598"></a>00598 <span class="keywordtype">void</span>
<a name="l00599"></a>00599 _fluid_seq_queue_pre_remove(fluid_sequencer_t* seq, <span class="keywordtype">short</span> src, <span class="keywordtype">short</span> dest, <span class="keywordtype">int</span> type)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601         fluid_evt_entry * evtentry = _fluid_seq_heap_get_free(seq-&gt;heap);
<a name="l00602"></a>00602         <span class="keywordflow">if</span> (evtentry == NULL) {
<a name="l00603"></a>00603                 <span class="comment">/* should not happen */</span>
<a name="l00604"></a>00604                 <a class="code" href="log_8h.html#3daee03b354d1f66f4ee180ca97ccfc6" title="Print a message to the log.">fluid_log</a>(<a class="code" href="log_8h.html#a341232c15addd9c336131984840ed9e62d9ddd89d0a853606ce38d195daa99a" title="The synth can&amp;#39;t function correctly any more.">FLUID_PANIC</a>, <span class="stringliteral">"sequencer: no more free events\n"</span>);
<a name="l00605"></a>00605                 <span class="keywordflow">return</span>;
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         evtentry-&gt;next = NULL;
<a name="l00609"></a>00609         evtentry-&gt;entryType = FLUID_EVT_ENTRY_REMOVE;
<a name="l00610"></a>00610         {
<a name="l00611"></a>00611                 fluid_event_t* evt = &amp;(evtentry-&gt;evt);
<a name="l00612"></a>00612                 <a class="code" href="event_8h.html#22e7fc6d5ce4ca9eab6dd6d60c85d78b" title="Set source of a sequencer event (DOCME).">fluid_event_set_source</a>(evt, src);
<a name="l00613"></a>00613                 <a class="code" href="event_8h.html#22e7fc6d5ce4ca9eab6dd6d60c85d78b" title="Set source of a sequencer event (DOCME).">fluid_event_set_source</a>(evt, src);
<a name="l00614"></a>00614                 <a class="code" href="event_8h.html#e0857e30ffdcfe4e277eb3c55df7ba32" title="Set destination of a sequencer event (DOCME).">fluid_event_set_dest</a>(evt, dest);
<a name="l00615"></a>00615                 evt-&gt;type = type;
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618         fluid_mutex_lock(seq-&gt;mutex);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         <span class="comment">/* append to preQueue */</span>
<a name="l00621"></a>00621         <span class="keywordflow">if</span> (seq-&gt;preQueueLast) {
<a name="l00622"></a>00622                 seq-&gt;preQueueLast-&gt;next = evtentry;
<a name="l00623"></a>00623         } <span class="keywordflow">else</span> {
<a name="l00624"></a>00624                 seq-&gt;preQueue = evtentry;
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626         seq-&gt;preQueueLast = evtentry;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         fluid_mutex_unlock(seq-&gt;mutex);
<a name="l00629"></a>00629         <span class="keywordflow">return</span>;
<a name="l00630"></a>00630 }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="comment">/***********************</span>
<a name="l00633"></a>00633 <span class="comment"> * callback from timer</span>
<a name="l00634"></a>00634 <span class="comment"> * (may be in a different thread, or in an interrupt)</span>
<a name="l00635"></a>00635 <span class="comment"> *</span>
<a name="l00636"></a>00636 <span class="comment"> ***********************/</span>
<a name="l00637"></a>00637 <span class="keywordtype">int</span>
<a name="l00638"></a>00638 _fluid_seq_queue_process(<span class="keywordtype">void</span>* data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msec)
<a name="l00639"></a>00639 {
<a name="l00640"></a>00640         fluid_sequencer_t* seq = (fluid_sequencer_t *)data;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642         <span class="comment">/* process prequeue */</span>
<a name="l00643"></a>00643         fluid_evt_entry* tmp;
<a name="l00644"></a>00644         fluid_evt_entry* next;
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         fluid_mutex_lock(seq-&gt;mutex);
<a name="l00647"></a>00647 
<a name="l00648"></a>00648         <span class="comment">/* get the preQueue */</span>
<a name="l00649"></a>00649         tmp = seq-&gt;preQueue;
<a name="l00650"></a>00650         seq-&gt;preQueue = NULL;
<a name="l00651"></a>00651         seq-&gt;preQueueLast = NULL;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         fluid_mutex_unlock(seq-&gt;mutex);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         <span class="comment">/* walk all the preQueue and process them in order : inserts and removes */</span>
<a name="l00656"></a>00656         <span class="keywordflow">while</span> (tmp) {
<a name="l00657"></a>00657                 next = tmp-&gt;next;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659                 <span class="keywordflow">if</span> (tmp-&gt;entryType == FLUID_EVT_ENTRY_REMOVE) {
<a name="l00660"></a>00660                         _fluid_seq_queue_remove_entries_matching(seq, tmp);
<a name="l00661"></a>00661                 } <span class="keywordflow">else</span> {
<a name="l00662"></a>00662                         _fluid_seq_queue_insert_entry(seq, tmp);
<a name="l00663"></a>00663                 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665                 tmp = next;
<a name="l00666"></a>00666         }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668         <span class="comment">/* send queued events */</span>
<a name="l00669"></a>00669         _fluid_seq_queue_send_queued_events(seq);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         <span class="comment">/* continue timer */</span>
<a name="l00672"></a>00672         <span class="keywordflow">return</span> 1;
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 <span class="keywordtype">void</span>
<a name="l00677"></a>00677 _fluid_seq_queue_print_later(fluid_sequencer_t* seq)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679         <span class="keywordtype">int</span> count = 0;
<a name="l00680"></a>00680         fluid_evt_entry* tmp = seq-&gt;queueLater;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         printf(<span class="stringliteral">"queueLater:\n"</span>);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684         <span class="keywordflow">while</span> (tmp) {
<a name="l00685"></a>00685                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delay = tmp-&gt;evt.time - seq-&gt;queue0StartTime;
<a name="l00686"></a>00686                 printf(<span class="stringliteral">"queueLater: Delay = %i\n"</span>, delay);
<a name="l00687"></a>00687                 tmp = tmp-&gt;next;
<a name="l00688"></a>00688                 count++;
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690         printf(<span class="stringliteral">"queueLater: Total of %i events\n"</span>, count);
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keywordtype">void</span>
<a name="l00695"></a>00695 _fluid_seq_queue_insert_queue0(fluid_sequencer_t* seq, fluid_evt_entry* tmp, <span class="keywordtype">int</span> cell)
<a name="l00696"></a>00696 {
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (seq-&gt;queue0[cell][1] == NULL) {
<a name="l00698"></a>00698                 seq-&gt;queue0[cell][1] = seq-&gt;queue0[cell][0] = tmp;
<a name="l00699"></a>00699         } <span class="keywordflow">else</span> {
<a name="l00700"></a>00700                 seq-&gt;queue0[cell][1]-&gt;next = tmp;
<a name="l00701"></a>00701                 seq-&gt;queue0[cell][1] = tmp;
<a name="l00702"></a>00702         }
<a name="l00703"></a>00703         tmp-&gt;next = NULL;
<a name="l00704"></a>00704 }
<a name="l00705"></a>00705 
<a name="l00706"></a>00706 <span class="keywordtype">void</span>
<a name="l00707"></a>00707 _fluid_seq_queue_insert_queue1(fluid_sequencer_t* seq, fluid_evt_entry* tmp, <span class="keywordtype">int</span> cell)
<a name="l00708"></a>00708 {
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (seq-&gt;queue1[cell][1] == NULL) {
<a name="l00710"></a>00710                 seq-&gt;queue1[cell][1] = seq-&gt;queue1[cell][0] = tmp;
<a name="l00711"></a>00711         } <span class="keywordflow">else</span> {
<a name="l00712"></a>00712                 seq-&gt;queue1[cell][1]-&gt;next = tmp;
<a name="l00713"></a>00713                 seq-&gt;queue1[cell][1] = tmp;
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715         tmp-&gt;next = NULL;
<a name="l00716"></a>00716 }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718 <span class="keywordtype">void</span>
<a name="l00719"></a>00719 _fluid_seq_queue_insert_queue_later(fluid_sequencer_t* seq, fluid_evt_entry* evtentry)
<a name="l00720"></a>00720 {
<a name="l00721"></a>00721         fluid_evt_entry* prev;
<a name="l00722"></a>00722         fluid_evt_entry* tmp;
<a name="l00723"></a>00723         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time = evtentry-&gt;evt.time;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         <span class="comment">/* insert in 'queueLater', after the ones that have the same</span>
<a name="l00726"></a>00726 <span class="comment">         * time */</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728         <span class="comment">/* first? */</span>
<a name="l00729"></a>00729         <span class="keywordflow">if</span> ((seq-&gt;queueLater == NULL)
<a name="l00730"></a>00730             || (seq-&gt;queueLater-&gt;evt.time &gt; time)) {
<a name="l00731"></a>00731                 evtentry-&gt;next = seq-&gt;queueLater;
<a name="l00732"></a>00732                 seq-&gt;queueLater = evtentry;
<a name="l00733"></a>00733                 <span class="keywordflow">return</span>;
<a name="l00734"></a>00734         }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736         <span class="comment">/* walk queueLater */</span>
<a name="l00737"></a>00737         <span class="comment">/* this is the only slow thing : if the event is more</span>
<a name="l00738"></a>00738 <span class="comment">           than 65535 ticks after the current time */</span>
<a name="l00739"></a>00739 
<a name="l00740"></a>00740         prev = seq-&gt;queueLater;
<a name="l00741"></a>00741         tmp = prev-&gt;next;
<a name="l00742"></a>00742         <span class="keywordflow">while</span> (tmp) {
<a name="l00743"></a>00743                 <span class="keywordflow">if</span> (tmp-&gt;evt.time &gt; time) {
<a name="l00744"></a>00744                         <span class="comment">/* insert before tmp */</span>
<a name="l00745"></a>00745                         evtentry-&gt;next = tmp;
<a name="l00746"></a>00746                         prev-&gt;next = evtentry;
<a name="l00747"></a>00747                         <span class="keywordflow">return</span>;
<a name="l00748"></a>00748                 }
<a name="l00749"></a>00749                 prev = tmp;
<a name="l00750"></a>00750                 tmp = prev-&gt;next;
<a name="l00751"></a>00751         }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         <span class="comment">/* last */</span>
<a name="l00754"></a>00754         evtentry-&gt;next = NULL;
<a name="l00755"></a>00755         prev-&gt;next = evtentry;
<a name="l00756"></a>00756 }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="keywordtype">void</span>
<a name="l00759"></a>00759 _fluid_seq_queue_insert_entry(fluid_sequencer_t* seq, fluid_evt_entry * evtentry)
<a name="l00760"></a>00760 {
<a name="l00761"></a>00761         <span class="comment">/* time is relative to seq origin, in ticks */</span>
<a name="l00762"></a>00762         fluid_event_t * evt = &amp;(evtentry-&gt;evt);
<a name="l00763"></a>00763         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time = evt-&gt;time;
<a name="l00764"></a>00764         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delay;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (seq-&gt;queue0StartTime &gt; 0) {
<a name="l00767"></a>00767                 <span class="comment">/* queue0StartTime could be &lt; 0 if the scale changed a</span>
<a name="l00768"></a>00768 <span class="comment">                   lot early, breaking the following comparison</span>
<a name="l00769"></a>00769 <span class="comment">                */</span>
<a name="l00770"></a>00770                 <span class="keywordflow">if</span> (time &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)seq-&gt;queue0StartTime) {
<a name="l00771"></a>00771                         <span class="comment">/* we are late, send now */</span>
<a name="l00772"></a>00772                         fluid_sequencer_send_now(seq, evt);
<a name="l00773"></a>00773 
<a name="l00774"></a>00774                         _fluid_seq_heap_set_free(seq-&gt;heap, evtentry);
<a name="l00775"></a>00775                         <span class="keywordflow">return</span>;
<a name="l00776"></a>00776                 }
<a name="l00777"></a>00777         }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         <span class="keywordflow">if</span> (seq-&gt;prevCellNb &gt;= 0) {
<a name="l00780"></a>00780                 <span class="comment">/* prevCellNb could be -1 is seq was just started - unlikely */</span>
<a name="l00781"></a>00781                 <span class="comment">/* prevCellNb can also be -1 if cellNb was reset to 0 in</span>
<a name="l00782"></a>00782 <span class="comment">                   _fluid_seq_queue_send_queued_events() */</span>
<a name="l00783"></a>00783                 <span class="keywordflow">if</span> (time &lt;= (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(seq-&gt;queue0StartTime + seq-&gt;prevCellNb)) {
<a name="l00784"></a>00784                         <span class="comment">/* we are late, send now */</span>
<a name="l00785"></a>00785                         fluid_sequencer_send_now(seq, evt);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                         _fluid_seq_heap_set_free(seq-&gt;heap, evtentry);
<a name="l00788"></a>00788                         <span class="keywordflow">return</span>;
<a name="l00789"></a>00789                 }
<a name="l00790"></a>00790         }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         delay = time - seq-&gt;queue0StartTime;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         <span class="keywordflow">if</span> (delay &gt; 65535) {
<a name="l00795"></a>00795                 _fluid_seq_queue_insert_queue_later(seq, evtentry);
<a name="l00796"></a>00796 
<a name="l00797"></a>00797         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (delay &gt; 255) {
<a name="l00798"></a>00798                 _fluid_seq_queue_insert_queue1(seq, evtentry, delay/256 - 1);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         } <span class="keywordflow">else</span> {
<a name="l00801"></a>00801                 _fluid_seq_queue_insert_queue0(seq, evtentry, delay);
<a name="l00802"></a>00802         }
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="keywordtype">int</span>
<a name="l00806"></a>00806 _fluid_seq_queue_matchevent(fluid_event_t* evt, <span class="keywordtype">int</span> templType, <span class="keywordtype">short</span> templSrc, <span class="keywordtype">short</span> templDest)
<a name="l00807"></a>00807 {
<a name="l00808"></a>00808         <span class="keywordtype">int</span> eventType;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         <span class="keywordflow">if</span> (templSrc != -1 &amp;&amp; templSrc != <a class="code" href="event_8h.html#44e98166f9bb5dff24dce0a7f8551ba8" title="Get the source field from a sequencer event structure.">fluid_event_get_source</a>(evt))
<a name="l00811"></a>00811                 <span class="keywordflow">return</span> 0;
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         <span class="keywordflow">if</span> (templDest != -1 &amp;&amp; templDest != <a class="code" href="event_8h.html#e55407a115f1efdfefd8cd5ba58faae9" title="Get the dest field from a sequencer event structure.">fluid_event_get_dest</a>(evt))
<a name="l00814"></a>00814                 <span class="keywordflow">return</span> 0;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816         <span class="keywordflow">if</span> (templType == -1)
<a name="l00817"></a>00817                 <span class="keywordflow">return</span> 1;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819         eventType = <a class="code" href="event_8h.html#c3361e1714645e0afbf51ee49e8fee21" title="Get the event type (fluid_seq_event_type) field from a sequencer event structure...">fluid_event_get_type</a>(evt);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821         <span class="keywordflow">if</span> (templType == eventType)
<a name="l00822"></a>00822                 <span class="keywordflow">return</span> 1;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <span class="keywordflow">if</span> (templType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb37bcf291c28adf61758aed0145a69b9c" title="DOCME (used for remove_events only).">FLUID_SEQ_ANYCONTROLCHANGE</a>)
<a name="l00825"></a>00825                 <span class="keywordflow">if</span> (eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb291c7d4e11f8fc03b562e6a32fe49901" title="Pitch bend message.">FLUID_SEQ_PITCHBEND</a> ||
<a name="l00826"></a>00826                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb51375e58f50cda291818b26396df9659" title="Modulation controller event.">FLUID_SEQ_MODULATION</a> ||
<a name="l00827"></a>00827                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb25aa6c9385a294189c6b18544350734d" title="Sustain controller event.">FLUID_SEQ_SUSTAIN</a> ||
<a name="l00828"></a>00828                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640ebdbea6248d4dc02056e4c3d3c64930643" title="Stereo pan set event.">FLUID_SEQ_PAN</a> ||
<a name="l00829"></a>00829                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb0c1bce287e2eb79ab4295ca5a6ecf752" title="Volume set event.">FLUID_SEQ_VOLUME</a> ||
<a name="l00830"></a>00830                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb970b2bfee1d58337bbe268475d07784e" title="Reverb send set event.">FLUID_SEQ_REVERBSEND</a> ||
<a name="l00831"></a>00831                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640eb3071c5720b0b969045a4c0f8a3be40bf" title="MIDI control change event.">FLUID_SEQ_CONTROLCHANGE</a> ||
<a name="l00832"></a>00832                     eventType == <a class="code" href="event_8h.html#98ada1fab7a3785a41aa4003645640ebfc06ca89f49f130985ee86e6550b3118" title="Chorus send set event.">FLUID_SEQ_CHORUSSEND</a>)
<a name="l00833"></a>00833                         <span class="keywordflow">return</span> 1;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         <span class="keywordflow">return</span> 0;
<a name="l00836"></a>00836 }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="keywordtype">void</span>
<a name="l00839"></a>00839 _fluid_seq_queue_remove_entries_matching(fluid_sequencer_t* seq, fluid_evt_entry* templ)
<a name="l00840"></a>00840 {
<a name="l00841"></a>00841         <span class="comment">/* we walk everything : this is slow, but that is life */</span>
<a name="l00842"></a>00842         <span class="keywordtype">int</span> i, type;
<a name="l00843"></a>00843         <span class="keywordtype">short</span> src, dest;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         src = templ-&gt;evt.src;
<a name="l00846"></a>00846         dest = templ-&gt;evt.dest;
<a name="l00847"></a>00847         type = templ-&gt;evt.type;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="comment">/* we can set it free now */</span>
<a name="l00850"></a>00850         _fluid_seq_heap_set_free(seq-&gt;heap, templ);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852         <span class="comment">/* queue0 */</span>
<a name="l00853"></a>00853         <span class="keywordflow">for</span> (i = 0 ; i &lt; 256 ; i++) {
<a name="l00854"></a>00854                 fluid_evt_entry* tmp = seq-&gt;queue0[i][0];
<a name="l00855"></a>00855                 fluid_evt_entry* prev = NULL;
<a name="l00856"></a>00856                 <span class="keywordflow">while</span> (tmp) {
<a name="l00857"></a>00857                         <span class="comment">/* remove and/or walk */</span>
<a name="l00858"></a>00858                         <span class="keywordflow">if</span> (_fluid_seq_queue_matchevent((&amp;tmp-&gt;evt), type, src, dest)) {
<a name="l00859"></a>00859                                 <span class="comment">/* remove */</span>
<a name="l00860"></a>00860                                 <span class="keywordflow">if</span> (prev) {
<a name="l00861"></a>00861                                         prev-&gt;next = tmp-&gt;next;
<a name="l00862"></a>00862                                         <span class="keywordflow">if</span> (tmp == seq-&gt;queue0[i][1]) <span class="comment">// last one in list</span>
<a name="l00863"></a>00863                                                 seq-&gt;queue0[i][1] = prev;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865                                         _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00866"></a>00866                                         tmp = prev-&gt;next;
<a name="l00867"></a>00867                                 } <span class="keywordflow">else</span> {
<a name="l00868"></a>00868                                         <span class="comment">/* first one in list */</span>
<a name="l00869"></a>00869                                         seq-&gt;queue0[i][0] = tmp-&gt;next;
<a name="l00870"></a>00870                                         <span class="keywordflow">if</span> (tmp == seq-&gt;queue0[i][1]) <span class="comment">// last one in list</span>
<a name="l00871"></a>00871                                                 seq-&gt;queue0[i][1] = NULL;
<a name="l00872"></a>00872 
<a name="l00873"></a>00873                                         _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00874"></a>00874                                         tmp = seq-&gt;queue0[i][0];
<a name="l00875"></a>00875                                 }
<a name="l00876"></a>00876                         } <span class="keywordflow">else</span> {
<a name="l00877"></a>00877                                 prev = tmp;
<a name="l00878"></a>00878                                 tmp = prev-&gt;next;
<a name="l00879"></a>00879                         }
<a name="l00880"></a>00880                 }
<a name="l00881"></a>00881         }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         <span class="comment">/* queue1 */</span>
<a name="l00884"></a>00884         <span class="keywordflow">for</span> (i = 0 ; i &lt; 255 ; i++) {
<a name="l00885"></a>00885                 fluid_evt_entry* tmp = seq-&gt;queue1[i][0];
<a name="l00886"></a>00886                 fluid_evt_entry* prev = NULL;
<a name="l00887"></a>00887                 <span class="keywordflow">while</span> (tmp) {
<a name="l00888"></a>00888                         <span class="keywordflow">if</span> (_fluid_seq_queue_matchevent((&amp;tmp-&gt;evt), type, src, dest)) {
<a name="l00889"></a>00889                                 <span class="comment">/* remove */</span>
<a name="l00890"></a>00890                                 <span class="keywordflow">if</span> (prev) {
<a name="l00891"></a>00891                                         prev-&gt;next = tmp-&gt;next;
<a name="l00892"></a>00892                                         <span class="keywordflow">if</span> (tmp == seq-&gt;queue1[i][1]) <span class="comment">// last one in list</span>
<a name="l00893"></a>00893                                                 seq-&gt;queue1[i][1] = prev;
<a name="l00894"></a>00894 
<a name="l00895"></a>00895                                         _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00896"></a>00896                                         tmp = prev-&gt;next;
<a name="l00897"></a>00897                                 } <span class="keywordflow">else</span> {
<a name="l00898"></a>00898                                         <span class="comment">/* first one in list */</span>
<a name="l00899"></a>00899                                         seq-&gt;queue1[i][0] = tmp-&gt;next;
<a name="l00900"></a>00900                                         <span class="keywordflow">if</span> (tmp == seq-&gt;queue1[i][1]) <span class="comment">// last one in list</span>
<a name="l00901"></a>00901                                                 seq-&gt;queue1[i][1] = NULL;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903                                         _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00904"></a>00904                                         tmp = seq-&gt;queue1[i][0];
<a name="l00905"></a>00905                                 }
<a name="l00906"></a>00906                         } <span class="keywordflow">else</span> {
<a name="l00907"></a>00907                                 prev = tmp;
<a name="l00908"></a>00908                                 tmp = prev-&gt;next;
<a name="l00909"></a>00909                         }
<a name="l00910"></a>00910                 }
<a name="l00911"></a>00911         }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         <span class="comment">/* queueLater */</span>
<a name="l00914"></a>00914         {
<a name="l00915"></a>00915                 fluid_evt_entry* tmp = seq-&gt;queueLater;
<a name="l00916"></a>00916                 fluid_evt_entry* prev = NULL;
<a name="l00917"></a>00917                 <span class="keywordflow">while</span> (tmp) {
<a name="l00918"></a>00918                         <span class="keywordflow">if</span> (_fluid_seq_queue_matchevent((&amp;tmp-&gt;evt), type, src, dest)) {
<a name="l00919"></a>00919                                 <span class="comment">/* remove */</span>
<a name="l00920"></a>00920                                 <span class="keywordflow">if</span> (prev) {
<a name="l00921"></a>00921                                         prev-&gt;next = tmp-&gt;next;
<a name="l00922"></a>00922 
<a name="l00923"></a>00923                                         _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00924"></a>00924                                         tmp = prev-&gt;next;
<a name="l00925"></a>00925                                 } <span class="keywordflow">else</span> {
<a name="l00926"></a>00926                                         seq-&gt;queueLater = tmp-&gt;next;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928                                         _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00929"></a>00929                                         tmp = seq-&gt;queueLater;
<a name="l00930"></a>00930                                 }
<a name="l00931"></a>00931                         } <span class="keywordflow">else</span> {
<a name="l00932"></a>00932                                 prev = tmp;
<a name="l00933"></a>00933                                 tmp = prev-&gt;next;
<a name="l00934"></a>00934                         }
<a name="l00935"></a>00935                 }
<a name="l00936"></a>00936         }
<a name="l00937"></a>00937 }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939 <span class="keywordtype">void</span>
<a name="l00940"></a>00940 _fluid_seq_queue_send_cell_events(fluid_sequencer_t* seq, <span class="keywordtype">int</span> cellNb)
<a name="l00941"></a>00941 {
<a name="l00942"></a>00942         fluid_evt_entry* next;
<a name="l00943"></a>00943         fluid_evt_entry* tmp;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945         tmp = seq-&gt;queue0[cellNb][0];
<a name="l00946"></a>00946         <span class="keywordflow">while</span> (tmp) {
<a name="l00947"></a>00947                 fluid_sequencer_send_now(seq, &amp;(tmp-&gt;evt));
<a name="l00948"></a>00948 
<a name="l00949"></a>00949                 next = tmp-&gt;next;
<a name="l00950"></a>00950 
<a name="l00951"></a>00951                 _fluid_seq_heap_set_free(seq-&gt;heap, tmp);
<a name="l00952"></a>00952                 tmp = next;
<a name="l00953"></a>00953         }
<a name="l00954"></a>00954         seq-&gt;queue0[cellNb][0] = NULL;
<a name="l00955"></a>00955         seq-&gt;queue0[cellNb][1] = NULL;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="keywordtype">void</span>
<a name="l00959"></a>00959 _fluid_seq_queue_slide(fluid_sequencer_t* seq)
<a name="l00960"></a>00960 {
<a name="l00961"></a>00961         <span class="keywordtype">short</span> i;
<a name="l00962"></a>00962         fluid_evt_entry* next;
<a name="l00963"></a>00963         fluid_evt_entry* tmp;
<a name="l00964"></a>00964         <span class="keywordtype">int</span> count = 0;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966         <span class="comment">/* do the slide */</span>
<a name="l00967"></a>00967         seq-&gt;queue0StartTime += 256;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         <span class="comment">/* sort all queue1[0] into queue0 according to new queue0StartTime */</span>
<a name="l00970"></a>00970         tmp = seq-&gt;queue1[0][0];
<a name="l00971"></a>00971         <span class="keywordflow">while</span> (tmp) {
<a name="l00972"></a>00972                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delay = tmp-&gt;evt.time - seq-&gt;queue0StartTime;
<a name="l00973"></a>00973                 next = tmp-&gt;next;
<a name="l00974"></a>00974                 <span class="keywordflow">if</span> (delay &gt; 255) {
<a name="l00975"></a>00975                         <span class="comment">/* should not happen !! */</span>
<a name="l00976"></a>00976                         <span class="comment">/* append it to queue1[1] */</span>
<a name="l00977"></a>00977                         _fluid_seq_queue_insert_queue1(seq, tmp, 1);
<a name="l00978"></a>00978                 } <span class="keywordflow">else</span> {
<a name="l00979"></a>00979                         _fluid_seq_queue_insert_queue0(seq, tmp, delay);
<a name="l00980"></a>00980                 }
<a name="l00981"></a>00981                 tmp = next;
<a name="l00982"></a>00982                 count++;
<a name="l00983"></a>00983         }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         <span class="comment">/* slide all queue1[i] into queue1[i-1] */</span>
<a name="l00986"></a>00986         <span class="keywordflow">for</span> (i = 1 ; i &lt; 255 ; i++) {
<a name="l00987"></a>00987                 seq-&gt;queue1[i-1][0] = seq-&gt;queue1[i][0];
<a name="l00988"></a>00988                 seq-&gt;queue1[i-1][1] = seq-&gt;queue1[i][1];
<a name="l00989"></a>00989         }
<a name="l00990"></a>00990         seq-&gt;queue1[254][0] = NULL;
<a name="l00991"></a>00991         seq-&gt;queue1[254][1] = NULL;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         <span class="comment">/* append queueLater to queue1[254] */</span>
<a name="l00995"></a>00995         count = 0;
<a name="l00996"></a>00996         tmp = seq-&gt;queueLater;
<a name="l00997"></a>00997         <span class="keywordflow">while</span> (tmp) {
<a name="l00998"></a>00998                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delay = tmp-&gt;evt.time - seq-&gt;queue0StartTime;
<a name="l00999"></a>00999 
<a name="l01000"></a>01000                 <span class="keywordflow">if</span> (delay &gt; 65535) {
<a name="l01001"></a>01001                         <span class="keywordflow">break</span>;
<a name="l01002"></a>01002                 }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004                 next = tmp-&gt;next;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006                 <span class="comment">/* append it */</span>
<a name="l01007"></a>01007                 _fluid_seq_queue_insert_queue1(seq, tmp, 254);
<a name="l01008"></a>01008                 tmp = next;
<a name="l01009"></a>01009                 count++;
<a name="l01010"></a>01010         }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012         seq-&gt;queueLater = tmp;
<a name="l01013"></a>01013 }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="keywordtype">void</span>
<a name="l01016"></a>01016 _fluid_seq_queue_send_queued_events(fluid_sequencer_t* seq)
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nowTicks = fluid_sequencer_get_tick(seq);
<a name="l01019"></a>01019         <span class="keywordtype">short</span> cellNb;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         cellNb = seq-&gt;prevCellNb + 1;
<a name="l01022"></a>01022         <span class="keywordflow">while</span> (cellNb &lt;= (<span class="keywordtype">int</span>)(nowTicks - seq-&gt;queue0StartTime)) {
<a name="l01023"></a>01023                 <span class="keywordflow">if</span> (cellNb == 256) {
<a name="l01024"></a>01024                         cellNb = 0;
<a name="l01025"></a>01025                         _fluid_seq_queue_slide(seq);
<a name="l01026"></a>01026                 } <span class="comment">/* slide */</span>
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 
<a name="l01029"></a>01029                 <span class="comment">/* process queue0[cellNb] */</span>
<a name="l01030"></a>01030                 _fluid_seq_queue_send_cell_events(seq, cellNb);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032                 <span class="comment">/* next cell */</span>
<a name="l01033"></a>01033                 cellNb++;
<a name="l01034"></a>01034         }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         seq-&gt;prevCellNb = cellNb - 1;
<a name="l01037"></a>01037 }
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 17 13:40:23 2007 for libfluidsynth by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
